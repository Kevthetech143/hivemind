-- Python Retry Pattern with Exponential Backoff
-- Source: Alpha agent refactoring
-- Production-ready decorator with jitter, logging, and monitoring hooks

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'Python retry decorator with exponential backoff and jitter',
    'python-patterns',
    'HIGH',
    '[
        {
            "solution": "Use production-ready decorator with validation, logging, and jitter",
            "percentage": 95,
            "note": "Full implementation with all best practices",
            "command": "import time\nimport random\nimport logging\nimport functools\nfrom typing import Callable, Type, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\ndef retry_with_backoff(\n    max_attempts: int = 3,\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    exponential_base: float = 2.0,\n    exceptions: Tuple[Type[Exception], ...] = (Exception,),\n    jitter: bool = True,\n    on_retry: Optional[Callable[[int, Exception, float], None]] = None\n):\n    # Input validation\n    if max_attempts < 1:\n        raise ValueError(f\"max_attempts must be >= 1, got {max_attempts}\")\n    if base_delay < 0 or max_delay < 0:\n        raise ValueError(\"Delays must be non-negative\")\n    if exponential_base <= 0:\n        raise ValueError(\"exponential_base must be > 0\")\n    \n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            errors = []\n            \n            for attempt in range(1, max_attempts + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    errors.append(e)\n                    \n                    if attempt >= max_attempts:\n                        logger.error(f\"{func.__name__} failed after {max_attempts} attempts\")\n                        raise Exception(f\"All {max_attempts} retry attempts failed\") from e\n                    \n                    # Calculate delay with jitter\n                    delay = min(base_delay * (exponential_base ** (attempt - 1)), max_delay)\n                    if jitter:\n                        delay *= (0.5 + random.random())\n                    \n                    logger.warning(\n                        f\"{func.__name__} attempt {attempt}/{max_attempts} failed: {e}. \"\n                        f\"Retrying in {delay:.2f}s...\"\n                    )\n                    \n                    # Call retry callback if provided\n                    if on_retry:\n                        on_retry(attempt, e, delay)\n                    \n                    time.sleep(delay)\n        \n        return wrapper\n    return decorator"
        },
        {
            "solution": "Add jitter to prevent thundering herd problem",
            "percentage": 90,
            "note": "Multiply delay by (0.5 + random.random()) for 50-150% randomization"
        },
        {
            "solution": "Use on_retry callback for metrics/monitoring integration",
            "percentage": 85,
            "note": "Pass attempt number, exception, and delay to callback for observability"
        },
        {
            "solution": "Chain exceptions with raise...from to preserve stack trace context",
            "percentage": 88,
            "note": "Prevents losing original error context in retry logic"
        }
    ]'::jsonb,
    'Python 3.7+, logging configured, functools available',
    'Functions retry automatically on failure, Exponential backoff visible in logs, Jitter prevents simultaneous retries, Exception chaining preserves context',
    'Do not use print() - use logging for library compatibility. Must validate input parameters to prevent invalid configs. Jitter is critical for distributed systems to prevent thundering herd. Exception chaining with from preserves stack traces.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/'
),
(
    'Python retry pattern: When to use exponential backoff vs fixed delay',
    'python-patterns',
    'HIGH',
    '[
        {
            "solution": "Use exponential backoff for rate limiting, API throttling, or transient network errors",
            "percentage": 95,
            "note": "Gives systems time to recover, prevents overwhelming already-stressed services"
        },
        {
            "solution": "Use fixed delay for predictable failures like database locks or file system contention",
            "percentage": 85,
            "note": "When you know the resource will be available in fixed time"
        },
        {
            "solution": "Combine exponential backoff with max_delay cap to prevent infinite wait times",
            "percentage": 92,
            "note": "Essential for production - prevents hours-long delays"
        }
    ]'::jsonb,
    'Understanding of failure modes in distributed systems',
    'Retries succeed without overwhelming downstream services, Logs show appropriate delay progression',
    'Exponential backoff without jitter causes thundering herd. No max_delay can lead to unacceptable wait times. Fixed delays can overwhelm recovering services.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/'
);
