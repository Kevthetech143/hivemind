INSERT INTO knowledge_entries (query, category, type, solutions, executable_type, prerequisites, common_pitfalls, success_indicators, preview_summary, source_url, contributor_email)
VALUES (
  'PostgreSQL Table Design - Design schemas with best practices for data types, indexing, constraints, performance, and advanced PostgreSQL features',
  'claude-code',
  'skill',
  '[{"solution":"Choose correct data types","manual":"IDs: BIGINT GENERATED ALWAYS AS IDENTITY (or UUID). Never use serial. Strings: TEXT (not VARCHAR). Money: NUMERIC(p,s) not float. Time: TIMESTAMPTZ (not TIMESTAMP). Booleans: BOOLEAN NOT NULL. Use JSONB over JSON for semi-structured data.","note":"Avoid: CHAR(n), VARCHAR(n), TIMESTAMP without timezone, SERIAL, MONEY type"},{"solution":"Define primary keys and constraints","manual":"Always add PRIMARY KEY, NOT NULL where required. Use UNIQUE + NULLS NOT DISTINCT (PG15+) to restrict NULLs. Add CHECK constraints for domain validation.","note":"PK creates auto B-tree index"},{"solution":"Create Foreign Key relationships","manual":"Always add FK constraints with ON DELETE/UPDATE actions (CASCADE, RESTRICT, SET NULL, SET DEFAULT). Manually add index on FK columns - PostgreSQL does not auto-index them.","note":"FK indexes critical for join performance and preventing lock issues"},{"solution":"Design appropriate indexes","manual":"B-tree for equality/range; GIN for JSONB/arrays; GiST for ranges/geometry; BRIN for time-series. Use composite indexes (order matters). Include covering columns for index-only scans.","note":"Only index what you query - every index slows inserts"},{"solution":"Normalize to 3NF, denormalize with proof","manual":"Eliminate data redundancy first. Only denormalize after measuring that join performance is problematic and ROI is proven. Use GENERATED COLUMNS for computed denormalized fields.","note":"Premature denormalization creates maintenance burden"},{"solution":"Implement Row-Level Security","manual":"Enable RLS on tables. Create policies for SELECT, INSERT, UPDATE, DELETE. Use USING for access control.","note":"Row-level access control at database level"},{"solution":"Partition for large tables or maintenance","manual":"Use RANGE partitioning for time-series (>100M rows). LIST for discrete values. HASH for even distribution. Include partition key in PK/UNIQUE.","note":"Declarative partitioning preferred (PG10+)"},{"solution":"Optimize for update-heavy or insert-heavy workloads","manual":"Update-heavy: separate hot/cold columns, use fillfactor=90, avoid updating indexed columns. Insert-heavy: minimize indexes, use COPY, defer index creation for bulk loads, use UNLOGGED tables for staging.","note":"Workload-specific optimization strategies"}]'::jsonb,
  'steps',
  'PostgreSQL database, SQL knowledge, understanding of relational database design, ACID properties',
  'Using SERIAL instead of GENERATED ALWAYS AS IDENTITY; Using VARCHAR(n) instead of TEXT; Using TIMESTAMP without timezone; Using MONEY type for monetary values; Not indexing FK columns; Storing sensitive data in JSONB; Premature denormalization; Using CHAR(n) for variable-length strings; Over-indexing; Not normalizing to 3NF',
  'Schema created successfully; All data types appropriate; Constraints properly defined; Indexes created for access paths; Queries use planned indexes; RLS policies enforce access control; Partitions created and working; Performance meets requirements; Zero constraint violations',
  'Master PostgreSQL schema design with best practices for data types, indexing, constraints, performance optimization, and advanced features',
  'https://skillsmp.com/skills/wshobson-agents-plugins-database-design-skills-postgresql-skill-md',
  'admin:HAIKU_SKILL_1764289759_1793'
);
