-- Contributor tracking system for reputation, banning, and rate limits

CREATE TABLE IF NOT EXISTS contributors (
    id SERIAL PRIMARY KEY,

    -- Identity (start with IP, upgrade to auth later)
    ip_address TEXT, -- For anonymous users
    email TEXT, -- Optional, for verified contributors
    github_username TEXT, -- Optional, for GitHub auth
    fingerprint TEXT, -- Browser fingerprint for additional tracking

    -- Status
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'banned', 'shadowban', 'trusted')),
    trust_level INTEGER DEFAULT 0, -- 0=new, 1=basic, 2=trusted, 3=moderator

    -- Reputation metrics
    contributions_count INTEGER DEFAULT 0,
    approved_count INTEGER DEFAULT 0,
    rejected_count INTEGER DEFAULT 0,
    votes_received INTEGER DEFAULT 0, -- Total votes on their contributions
    positive_votes INTEGER DEFAULT 0,
    negative_votes INTEGER DEFAULT 0,
    reputation_score NUMERIC DEFAULT 0.0, -- Calculated: (approved + positive_votes) / (total contributions + votes)

    -- Activity tracking
    first_seen_at TIMESTAMPTZ DEFAULT NOW(),
    last_seen_at TIMESTAMPTZ DEFAULT NOW(),
    total_searches INTEGER DEFAULT 0,
    total_contributions INTEGER DEFAULT 0,
    total_votes INTEGER DEFAULT 0,
    total_tickets INTEGER DEFAULT 0,

    -- Ban information
    banned_at TIMESTAMPTZ,
    banned_reason TEXT,
    banned_by TEXT, -- Admin username
    ban_expires_at TIMESTAMPTZ, -- NULL = permanent

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Unique constraints
    UNIQUE(ip_address),
    UNIQUE(email),
    UNIQUE(github_username)
);

-- Index for fast lookups
CREATE INDEX IF NOT EXISTS idx_contributors_ip ON contributors(ip_address);
CREATE INDEX IF NOT EXISTS idx_contributors_email ON contributors(email);
CREATE INDEX IF NOT EXISTS idx_contributors_status ON contributors(status);
CREATE INDEX IF NOT EXISTS idx_contributors_trust_level ON contributors(trust_level);

-- Add contributor tracking to existing tables
ALTER TABLE pending_contributions
ADD COLUMN IF NOT EXISTS contributor_id INTEGER REFERENCES contributors(id);

ALTER TABLE knowledge_entries
ADD COLUMN IF NOT EXISTS contributor_id INTEGER REFERENCES contributors(id);

ALTER TABLE troubleshooting_sessions
ADD COLUMN IF NOT EXISTS contributor_id INTEGER REFERENCES contributors(id);

-- Vote tracking table (NEW)
CREATE TABLE IF NOT EXISTS solution_votes (
    id SERIAL PRIMARY KEY,
    contributor_id INTEGER REFERENCES contributors(id) NOT NULL,
    solution_id INTEGER REFERENCES knowledge_entries(id) NOT NULL,
    vote_type TEXT CHECK (vote_type IN ('success', 'failure')) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- One vote per contributor per solution
    UNIQUE(contributor_id, solution_id)
);

CREATE INDEX IF NOT EXISTS idx_solution_votes_contributor ON solution_votes(contributor_id);
CREATE INDEX IF NOT EXISTS idx_solution_votes_solution ON solution_votes(solution_id);

-- Function: Get or create contributor by IP
CREATE OR REPLACE FUNCTION get_or_create_contributor(
    p_ip_address TEXT,
    p_email TEXT DEFAULT NULL,
    p_fingerprint TEXT DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    v_contributor_id INTEGER;
BEGIN
    -- Try to find by IP first
    SELECT id INTO v_contributor_id
    FROM contributors
    WHERE ip_address = p_ip_address;

    -- If not found, create new
    IF v_contributor_id IS NULL THEN
        INSERT INTO contributors (ip_address, email, fingerprint)
        VALUES (p_ip_address, p_email, p_fingerprint)
        RETURNING id INTO v_contributor_id;
    ELSE
        -- Update last seen
        UPDATE contributors
        SET last_seen_at = NOW(),
            email = COALESCE(p_email, email),
            fingerprint = COALESCE(p_fingerprint, fingerprint)
        WHERE id = v_contributor_id;
    END IF;

    RETURN v_contributor_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Check if contributor is banned
CREATE OR REPLACE FUNCTION is_contributor_banned(
    p_contributor_id INTEGER
)
RETURNS BOOLEAN AS $$
DECLARE
    v_status TEXT;
    v_ban_expires TIMESTAMPTZ;
BEGIN
    SELECT status, ban_expires_at INTO v_status, v_ban_expires
    FROM contributors
    WHERE id = p_contributor_id;

    -- Check status
    IF v_status = 'banned' THEN
        -- Check if ban expired
        IF v_ban_expires IS NOT NULL AND v_ban_expires < NOW() THEN
            -- Unban automatically
            UPDATE contributors
            SET status = 'active', banned_at = NULL, banned_reason = NULL, ban_expires_at = NULL
            WHERE id = p_contributor_id;
            RETURN FALSE;
        END IF;
        RETURN TRUE;
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- Function: Calculate reputation score
CREATE OR REPLACE FUNCTION update_contributor_reputation(
    p_contributor_id INTEGER
)
RETURNS VOID AS $$
DECLARE
    v_score NUMERIC;
BEGIN
    WITH stats AS (
        SELECT
            c.id,
            c.approved_count,
            c.rejected_count,
            c.positive_votes,
            c.negative_votes,
            c.contributions_count
        FROM contributors c
        WHERE c.id = p_contributor_id
    )
    SELECT
        CASE
            WHEN (contributions_count + positive_votes + negative_votes) = 0 THEN 0.5
            ELSE ROUND(
                (approved_count::NUMERIC * 2.0 + positive_votes::NUMERIC) /
                (contributions_count::NUMERIC * 2.0 + positive_votes::NUMERIC + negative_votes::NUMERIC + 1.0),
                3
            )
        END INTO v_score
    FROM stats;

    -- Update reputation and trust level
    UPDATE contributors
    SET
        reputation_score = v_score,
        trust_level = CASE
            WHEN v_score >= 0.9 AND approved_count >= 10 THEN 2 -- Trusted
            WHEN v_score >= 0.7 AND approved_count >= 5 THEN 1 -- Basic
            ELSE 0 -- New
        END,
        updated_at = NOW()
    WHERE id = p_contributor_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Get contributor rate limits based on trust level
CREATE OR REPLACE FUNCTION get_contributor_limits(
    p_contributor_id INTEGER
)
RETURNS TABLE (
    search_limit INTEGER,
    contribute_limit INTEGER,
    vote_limit INTEGER,
    ticket_limit INTEGER
) AS $$
DECLARE
    v_trust_level INTEGER;
    v_status TEXT;
BEGIN
    SELECT trust_level, status INTO v_trust_level, v_status
    FROM contributors
    WHERE id = p_contributor_id;

    -- Banned users get 0 limits
    IF v_status = 'banned' THEN
        RETURN QUERY SELECT 0, 0, 0, 0;
        RETURN;
    END IF;

    -- Set limits based on trust level
    RETURN QUERY SELECT
        CASE v_trust_level
            WHEN 0 THEN 50   -- New: 50 searches/hour
            WHEN 1 THEN 100  -- Basic: 100/hour
            WHEN 2 THEN 500  -- Trusted: 500/hour
            ELSE 1000        -- Moderator: 1000/hour
        END AS search_limit,
        CASE v_trust_level
            WHEN 0 THEN 5    -- New: 5 contributions/hour
            WHEN 1 THEN 10   -- Basic: 10/hour
            WHEN 2 THEN 50   -- Trusted: 50/hour
            ELSE 100         -- Moderator: 100/hour
        END AS contribute_limit,
        CASE v_trust_level
            WHEN 0 THEN 10   -- New: 10 votes/hour
            WHEN 1 THEN 20   -- Basic: 20/hour
            WHEN 2 THEN 100  -- Trusted: 100/hour
            ELSE 500         -- Moderator: 500/hour
        END AS vote_limit,
        CASE v_trust_level
            WHEN 0 THEN 3    -- New: 3 tickets/hour
            WHEN 1 THEN 5    -- Basic: 5/hour
            WHEN 2 THEN 20   -- Trusted: 20/hour
            ELSE 50          -- Moderator: 50/hour
        END AS ticket_limit;
END;
$$ LANGUAGE plpgsql;
