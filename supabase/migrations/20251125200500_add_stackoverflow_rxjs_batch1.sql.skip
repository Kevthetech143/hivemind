-- Stack Overflow RxJS Questions Batch 1
-- Mined: 2025-11-25
-- Category: stackoverflow-rxjs

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES
(
    'What is the difference between Promises and Observables in RxJS?',
    'stackoverflow-rxjs',
    'VERY_HIGH',
    '[
        {"solution": "Observables handle zero, one, or multiple asynchronous events, while Promises handle a single asynchronous event. Use Observable for streams and events, Promise for single async operations.", "percentage": 95, "note": "Most comprehensive explanation on Stack Overflow"},
        {"solution": "Observables support powerful operators like map, debounceTime, distinctUntilChanged, and retry for transforming data streams. Promises require manual workarounds for these patterns.", "percentage": 90, "note": "Practical advantage of Observables"},
        {"solution": "Observables support cancellation via unsubscribe(). Promises cannot be cancelled once initiated and are eager in execution.", "percentage": 85, "note": "Key difference in control and execution model"}
    ]'::jsonb,
    'Understanding of async patterns, Basic RxJS/Promise knowledge',
    'Understanding when to use Observables vs Promises, Able to implement debouncing with Observable operators',
    'Mixing Promise patterns with Observable when both are needed. Not understanding lazy vs eager execution. Over-using Promises when Observables are better suited.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/37364973/what-is-the-difference-between-promises-and-observables'
),
(
    'Angular/RxJS: When should I unsubscribe from Subscription?',
    'stackoverflow-rxjs',
    'VERY_HIGH',
    '[
        {"solution": "Use takeUntil operator with a destroy subject to automatically unsubscribe in ngOnDestroy lifecycle hook", "percentage": 95, "note": "Modern best practice pattern"},
        {"solution": "Manually call unsubscribe() on subscription in ngOnDestroy to prevent side effects after component destruction", "percentage": 90, "note": "Traditional approach still valid"},
        {"solution": "Use async pipe in templates to automatically handle subscription cleanup", "percentage": 88, "note": "Works well for template binding scenarios"}
    ]'::jsonb,
    'Angular component understanding, RxJS Subjects knowledge, Understanding of lifecycle hooks',
    'Subscriptions properly cleaned up, No memory leaks, No errors from destroyed components processing responses',
    'Forgetting to unsubscribe causing out-of-context execution when responses arrive after component destruction. Only focusing on memory leaks, ignoring side effect problems. Not using takeUntil pattern consistently.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/47152752/angular-subscribe-unsubscribe-best-practices'
),
(
    'What is the difference between BehaviorSubject and Observable?',
    'stackoverflow-rxjs',
    'VERY_HIGH',
    '[
        {"solution": "Observable is a function with no state. BehaviorSubject stores state and always has a current value that is emitted immediately to new subscribers.", "percentage": 95, "note": "Core conceptual difference"},
        {"solution": "Use BehaviorSubject for shared state management. Use Observable for one-time or simple async operations.", "percentage": 92, "note": "Practical usage guidance"},
        {"solution": "Access BehaviorSubject current value synchronously with .value property or .getValue() method", "percentage": 88, "note": "Important capability difference"}
    ]'::jsonb,
    'Basic RxJS understanding, Understanding of subjects vs observables',
    'Correct instantiation with initial value for BehaviorSubject, New subscribers receive current value immediately',
    'Using Observable when you need to maintain state. Using BehaviorSubject for one-off operations. Forgetting BehaviorSubject requires initial value. Assuming regular Observables store state.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/39494058/what-is-the-difference-between-behaviorsubject-and-observable'
),
(
    'What is the difference between Subject and BehaviorSubject?',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "Subject does not retain values - subscribers only get values emitted after subscription. BehaviorSubject holds last value and emits it immediately to new subscribers.", "percentage": 95, "note": "Primary distinction"},
        {"solution": "Use Subject for event streams (fire-and-forget). Use BehaviorSubject for state management.", "percentage": 92, "note": "Guides correct selection"},
        {"solution": "BehaviorSubject requires initial value at creation, Subject does not", "percentage": 90, "note": "API difference"}
    ]'::jsonb,
    'RxJS Subjects knowledge, Understanding state vs events',
    'Values correctly emitted based on subscription timing, State properly retained in BehaviorSubject scenarios',
    'Treating Subject and BehaviorSubject interchangeably. Expecting Subject to retain values. Not providing initial value to BehaviorSubject. Using Subject for state management.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/43348463/what-is-the-difference-between-subject-and-behaviorsubject'
),
(
    'How to convert Promise to Observable in RxJS?',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "Use defer(() => from(promise)) to combine defer for lazy execution with from for Promise conversion, ensuring proper Observable semantics", "percentage": 95, "note": "Best practice combining both operators"},
        {"solution": "Use from(promise) directly for simple Promise to Observable conversion, but note this creates a hot Observable that executes immediately", "percentage": 85, "note": "Simple approach with caveats"},
        {"solution": "Wrap promise in defer() to ensure lazy evaluation matching Observable behavior", "percentage": 90, "note": "Ensures Observable contract compliance"}
    ]'::jsonb,
    'RxJS version 5.5+, Understanding of Promises, Understanding lazy vs eager execution',
    'Promise successfully converted to Observable, Observable only executes on subscription, Works with RxJS operators like pipe',
    'Using from(promise) when lazy evaluation is needed - Promise executes before subscription. Forgetting defer() wrapper. Not using defer(() => from()) pattern for proper Observable semantics.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/39319279/convert-promise-to-observable'
),
(
    'Is it necessary to unsubscribe from observables created by Http methods to avoid memory leaks?',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "HTTP Observables auto-complete after response, so technically not required for memory leak prevention, but unsubscribe is still recommended to prevent side effects", "percentage": 90, "note": "Clarifies technical reality vs best practice"},
        {"solution": "Use takeUntil() or take(1) to ensure subscriptions cleanup even if responses arrive after component destruction", "percentage": 88, "note": "Prevents unwanted side effects"},
        {"solution": "Use timeout() operator to prevent orphaned subscriptions from hanging indefinitely", "percentage": 82, "note": "Additional safety measure"}
    ]'::jsonb,
    'Angular HTTP client understanding, RxJS operators knowledge',
    'No memory leaks, No out-of-context execution when component destroyed before response arrives',
    'Assuming HTTP Observables never need cleanup. Ignoring side effects from delayed responses. Only focusing on memory, not execution context. Not using timeout operators with HTTP calls.',
    0.87,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/35042929/is-it-necessary-to-unsubscribe-from-observables-created-by-http-methods-to-avoid-memory-leaks'
),
(
    'What is the correct way to share the result of an Angular Http network call in RxJS?',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "Use shareReplay(1) operator for caching HTTP responses and sharing among multiple subscribers (RxJS 5.4.0+)", "percentage": 94, "note": "Modern best practice, handles edge cases well"},
        {"solution": "Use share() operator for sharing current request among multiple subscribers without caching", "percentage": 85, "note": "Simpler but no response replay after completion"},
        {"solution": "Manually cache with Observable.of() for cached data and store promise for in-flight requests", "percentage": 80, "note": "Manual approach with more control"}
    ]'::jsonb,
    'RxJS 5.4+ for shareReplay, Understanding of hot vs cold observables, Angular HTTP client knowledge',
    'Multiple subscribers share single HTTP request, Cached responses returned to new subscribers, Proper cleanup on unsubscribe',
    'Using share() for caching - it does not replay responses after completion. Forgetting that shareReplay requires proper refCount handling. Not resetting cache when data becomes stale. Every subscription triggering new HTTP request.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/36271899/what-is-the-correct-way-to-share-the-result-of-an-angular-http-network-call-in-r'
),
(
    'How to fix: map is not a function with Angular http.get()',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "For Angular 5+, import map from rxjs/operators and use pipe: import { map } from ''rxjs/operators''; then .pipe(map(res => res.json()))", "percentage": 96, "note": "Modern recommended approach"},
        {"solution": "For Angular 2-4, add import ''rxjs/add/operator/map''; at top of service file to patch the operator onto Observable", "percentage": 92, "note": "Legacy RxJS 5 pattern"},
        {"solution": "Ensure you are using Observable-returning http.get, not Promise-returning library methods like Ionic Native HTTP", "percentage": 85, "note": "Common mistake - wrong HTTP library"}
    ]'::jsonb,
    'Angular 2+, RxJS 5 or 6+, Understanding of Observable operators',
    'map operator available on Observable, Code compiles without errors, Response data properly transformed',
    'Importing from rxjs/Rx (bloats bundle). Using map without pipe() in RxJS 6. Confusing Ionic Native HTTP (returns Promise) with Angular HTTP (returns Observable). Missing import statements.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/34515173/angular-http-get-with-typescript-error-http-get-map-is-not-a-function-in-n'
),
(
    'How to get current value of RxJS Subject or Observable?',
    'stackoverflow-rxjs',
    'HIGH',
    '[
        {"solution": "Use BehaviorSubject instead of Subject or Observable if you need to access current value - call .value or .getValue() property", "percentage": 96, "note": "Primary solution when current value access is needed"},
        {"solution": "Tap into the stream with tap() operator to capture latest value in a variable, then read that variable", "percentage": 82, "note": "Workaround when BehaviorSubject not available"},
        {"solution": "For RxJS 6.1+, use firstValueFrom() or lastValueFrom() to convert Observable to Promise and extract current value", "percentage": 80, "note": "Modern alternative approach"}
    ]'::jsonb,
    'RxJS 5.0+ (or 6.1+ for firstValueFrom), Understanding of Observable vs Subject semantics',
    'Current value successfully retrieved, Works with Observable semantics, No errors from undefined values',
    'Trying to access current value from regular Observable or Subject - they do not store state. Using getValue() on Subject - only BehaviorSubject has this. Assuming Observables maintain state. Not initializing BehaviorSubject with value.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/37089977/how-to-get-current-value-of-rxjs-subject-or-observable'
),
(
    'RxJS: Return an empty Observable',
    'stackoverflow-rxjs',
    'MEDIUM',
    '[
        {"solution": "For RxJS 6+, use EMPTY constant: import { EMPTY } from ''rxjs''; return EMPTY;", "percentage": 95, "note": "Modern best practice, completes without emitting"},
        {"solution": "For RxJS 5.5+, use empty() function: import { empty } from ''rxjs/observable/empty''; return empty();", "percentage": 90, "note": "Works but deprecated approach"},
        {"solution": "Use of() with no arguments to return completed observable without emitting: return of();", "percentage": 82, "note": "Alternative that works in all versions"}
    ]'::jsonb,
    'RxJS 5.5 or higher, Understanding of observable completion',
    'Observable completes without emitting any value, subscribe() callback does not execute, Observable chain continues to next operators',
    'Using of() with empty object: of({}) - this emits the empty object, not nothing. Confusion between EMPTY, empty(), and of(). Not understanding that EMPTY never calls next callback. Expecting empty Observable to trigger subscribe handlers.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/38548407/return-an-empty-observable'
),
(
    'RxJS take(1) vs first() operators - what is the difference?',
    'stackoverflow-rxjs',
    'MEDIUM',
    '[
        {"solution": "take(1) emits first value and completes silently. first() throws error on empty Observable. Use take(1) for general cases.", "percentage": 94, "note": "Key behavioral difference"},
        {"solution": "first() can accept a predicate function and throws error if predicate never matches. take(1) ignores predicates.", "percentage": 88, "note": "Different parameter handling"},
        {"solution": "Both complete subscription after first emission. Use take(1) unless you specifically need error handling on empty streams.", "percentage": 85, "note": "Usage recommendation"}
    ]'::jsonb,
    'RxJS 5+, Understanding of Observable completion and error handling',
    'Correct operator selected for stream type, Proper error handling for empty streams, Subscription properly cleaned up after first emission',
    'Using first() on potentially empty Observables without error handling. Assuming take(1) and first() are interchangeable. Not catching errors from first() on empty streams. Using first() with no error handler.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/42345969/take1-vs-first'
),
(
    'RxJS: What is the difference between of() and from() operators?',
    'stackoverflow-rxjs',
    'MEDIUM',
    '[
        {"solution": "of() treats arguments as individual values and emits each one: of(1,2,3) emits 1, then 2, then 3. from() unpacks iterables/arrays: from([1,2,3]) also emits 1, then 2, then 3", "percentage": 94, "note": "Core difference in argument handling"},
        {"solution": "of([1,2,3]) emits the entire array as one value. from([1,2,3]) emits each element individually.", "percentage": 92, "note": "Practical example of key difference"},
        {"solution": "from() accepts Promises, Iterables, Observables. of() only accepts values. Use from() for conversions, of() for discrete values.", "percentage": 89, "note": "Broader capability of from"}
    ]'::jsonb,
    'RxJS 5.5+, Understanding of iterables and array unpacking',
    'Arrays/iterables properly unpacked or grouped based on operator choice, Correct number of emissions, Proper handling of Promise conversion with from()',
    'Using of([...]) when array unpacking is needed. Using from() for discrete values. Forgetting of(...spread) achieves from-like behavior. Not understanding from() accepts Promises. Mixing argument patterns between of and from.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/42704552/of-vs-from-operator'
),
(
    'RxJS subscribe is deprecated: Use an observer instead of error callback',
    'stackoverflow-rxjs',
    'MEDIUM',
    '[
        {"solution": "Replace old pattern with observer object: .subscribe({ next: handler, error: errorHandler, complete: completeHandler })", "percentage": 95, "note": "Modern recommended pattern"},
        {"solution": "Old deprecated pattern: .subscribe(nextFn, errorFn, completeFn) - this overload will be removed in RxJS v8", "percentage": 92, "note": "Pattern to avoid"},
        {"solution": "Observer object allows optional handlers: omit any key you do not need without undefined placeholders", "percentage": 88, "note": "Flexibility benefit"}
    ]'::jsonb,
    'RxJS 6.5+, Understanding of observer pattern',
    'Code compiles without deprecation warnings, All handlers properly invoked (next, error, complete), Works with RxJS v8+ when deprecated overloads removed',
    'Still using callback-style subscribe with multiple arguments. Not converting existing code to observer pattern. Mixing deprecated and new subscribe patterns. Assuming subscribe() itself is deprecated - only specific overloads are.',
    0.87,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/55472124/subscribe-is-deprecated-use-an-observer-instead-of-an-error-callback'
)
ON CONFLICT DO NOTHING;
