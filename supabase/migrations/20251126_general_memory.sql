-- Mining: General Memory errors (10 entries)
-- Mined: 2025-11-26
-- Miner: haiku-1764191757

INSERT INTO knowledge_entries (query, category, hit_frequency, solutions, prerequisites, success_indicators, common_pitfalls, success_rate, claude_version, last_verified, source_url, contributor_email) VALUES

('Svelte 5 memory leak with array shift causing deleted objects to accumulate', 'general', 'HIGH', '[{"solution": "Replace array.shift() with array.slice(1) or array.pop() instead. shift() can leave references in some SvelteJS versions. Use immutable operations: circles = circles.slice(1) instead of circles.shift()", "percentage": 95}, {"solution": "Clear all references manually: circles.splice(0, 1) with explicit garbage collection trigger", "percentage": 85}]'::jsonb, 'Svelte 4+ project, array state with object instances', 'Run heap snapshots in Chrome DevTools. Delete items and verify object count decreases. Inspect memory tab to confirm no orphaned instances', 'Forgetting that shift() leaves references, using mutable operations, not checking heap with DevTools', 0.92, 'haiku', NOW(), 'https://stackoverflow.com/questions/79555156/svelte-5-memory-leak-in-simple-example', 'admin:1764191757'),

('SolidJS computations created outside createRoot or render will never be disposed warning', 'general', 'HIGH', '[{"solution": "Wrap async code and DOM element creation inside createRoot() or use runWithOwner(). Never create reactive computations in setTimeout/async handlers without proper owner: const msg = createSignal(). Use: async function saveForm(){ await callApi(); } inside render context or wrap with createRoot", "percentage": 94}, {"solution": "Use runWithOwner(getOwner(), () => { createSignal(...) }) to preserve ownership tree for async operations", "percentage": 88}]'::jsonb, 'SolidJS 1.0+, JSX components with async functions', 'No console warnings about computations created outside root. Verify in Chrome DevTools that memory stays stable during async operations. No memory growth after repeated async calls', 'Creating signals/effects in setTimeout/event handlers, creating JSX in async functions, missing createRoot wrapper', 0.91, 'haiku', NOW(), 'https://stackoverflow.com/questions/70373659/solidjs-computations-created-outside-a-createroot-or-render-will-never-be', 'admin:1764191757'),

('ApexCharts in SolidJS progressively slower after hundreds of updates with memory accumulation', 'general', 'HIGH', '[{"solution": "Immutable data updates with ApexCharts cause memory bloat. Switch to Chart.js or D3.js for SolidJS. If must use ApexCharts: use mutable store with appendData() instead of updateSeries(). Store data mutably to prevent object duplication: Keep 100-point buffer using splice not shift", "percentage": 92}, {"solution": "Replace ApexCharts entirely. ChartJS integrates better with SolidJS reactivity and does not accumulate memory with live updates", "percentage": 89}]'::jsonb, 'SolidJS with ApexCharts, live chart updates >1Hz', 'Memory stable under 200MB for 1000+ updates. CPU load <5%. Chart updates instant with no lag. Check heap in DevTools - no growth over time', 'Using updateSeries() with immutable data, keeping array of old snapshots, not clearing ApexCharts cache', 0.89, 'haiku', NOW(), 'https://stackoverflow.com/questions/75725958/apexcharts-in-solidjs-updating-the-chart-is-getting-progressively-slower-after', 'admin:1764191757'),

('Remix dev mode in-memory cache always empty on each request due to require() purge on live reload', 'general', 'HIGH', '[{"solution": "Assign cache to global object to survive live reload purges. Create utils/singleton.server.ts: export function singleton<Value>(name: string, value: () => Value): Value { const yolo = global as any; yolo.__singletons ??= {}; yolo.__singletons[name] ??= value(); return yolo.__singletons[name] }. Then: const cache = singleton(''cache'', () => new LRU({ max: 200 }))", "percentage": 96}, {"solution": "Use global.__cache pattern: if (process.env.NODE_ENV === ''production'') { cache = new NodeCache() } else { if (!global.__cache) global.__cache = new NodeCache(); cache = global.__cache }", "percentage": 94}]'::jsonb, 'Remix dev environment, lru-cache or NodeCache library', 'Cache persists across requests in dev. console.log(''Creating cache'') logs only once. Production and dev behave identically', 'Forgetting global object assignment, using const cache instead of attaching to global, not handling production vs dev', 0.95, 'haiku', NOW(), 'https://stackoverflow.com/questions/72661999/how-do-i-use-in-memory-cache-in-remix-run-dev-mode', 'admin:1764191757'),

('React Query mutation onSuccess callback updates state on unmounted component causing memory leak warning', 'general', 'MEDIUM', '[{"solution": "Use .mutate() callback instead of useMutation onSuccess. These are only called if component still mounted: useMutation(fn, { mutationFn: async () => {...} }).mutate(data, { onSuccess: (data) => { setImages(...) } }). Alternative: Store result in React Query cache instead: queryClient.setQueryData(''images'', prev => [...prev, data])", "percentage": 93}, {"solution": "Track mount state with useRef: const mounted = useRef(true); useEffect(() => { return () => { mounted.current = false } }, []); Then: onSuccess: if (mounted.current) { setImages(...) }", "percentage": 82}]'::jsonb, 'React + React Query/TanStack Query, mutation in component', 'No console warnings about memory leaks. Component unmounting does not call setImages. State updates only on mounted components', 'Using useMutation onSuccess instead of .mutate callback, ignoring React 18 warning removal, using ref patterns that don''t work', 0.90, 'haiku', NOW(), 'https://stackoverflow.com/questions/71283217/updating-react-state-inside-react-query-onsuccess-event-causes-a-memory-leak', 'admin:1764191757'),

('Rollup dev server ''FATAL ERROR: Reached heap limit'' with allocation failure during build', 'general', 'HIGH', '[{"solution": "Increase Node.js heap allocation: export NODE_OPTIONS=--max-old-space-size=8192 (8GB). Start npm run dev with: NODE_OPTIONS=--max-old-space-size=8192 npm run dev. Adjust 8192 to larger multiple of 1024 if app is larger", "percentage": 97}, {"solution": "Use node-max-old-space-size npm package to auto-allocate. Or set in package.json: ''dev'': ''cross-env NODE_OPTIONS=--max-old-space-size=8192 rollup -c'', "percentage": 85}]'::jsonb, 'Rollup bundler, Svelte/Node project, 4GB+ source files', 'npm run dev completes without heap errors. Build finishes in <2min. No ''FATAL ERROR'' messages', 'Using default Node heap (512MB), not adjusting for large projects, temporary fix with export (lost on shell restart)', 0.94, 'haiku', NOW(), 'https://stackoverflow.com/questions/70204891/rollup-run-dev-aborts', 'admin:1764191757'),

('Vite SvelteKit dev server freezes and crashes with heap out of memory on localhost load', 'general', 'HIGH', '[{"solution": "Increase Node heap before start: NODE_OPTIONS=--max-old-space-size=8192 npm run dev. SvelteKit Vite plugin has memory leak in watch mode. Alternative: Use production build for testing if possible. Check for infinite loops in +page.svelte or +layout.svelte", "percentage": 95}, {"solution": "Disable SvelteKit HMR/LiveReload temporarily: Create vite.config.ts with hmr: false. This trades reload for stability. Or: use --experimental-hmr-websocket flag", "percentage": 78}]'::jsonb, 'SvelteKit 1.0+, Vite dev environment, localhost:5173', 'npm run dev starts without freezing. Localhost page loads in <5sec. No FATAL ERROR heap messages. Memory <1GB', 'Default Node heap, infinite loops in components, not checking Vite plugin version, forgetting npm run dev vs npm run build', 0.92, 'haiku', NOW(), 'https://stackoverflow.com/questions/76284694/vite-sveltekit-unresponsive-white-website', 'admin:1764191757'),

('SolidJS setStore TypeScript wrapper loses overload types with spread parameters', 'general', 'MEDIUM', '[{"solution": "Use any[] parameter and cast setStore to any: const setStoreWithEffect: SetStoreFunction<T> = (...params: any[]) => { /* effect code */; return (setStore as any)(...params) }. This preserves IntelliSense while allowing wrapper function", "percentage": 91}, {"solution": "Use @ts-expect-error directive if type safety needed: // @ts-expect-error: Not assignable. const setStoreWithEffect: SetStoreFunction<T> = (...params: [any]) => { /* effect */; return setStore(...params) }", "percentage": 75}]'::jsonb, 'SolidJS with TypeScript, createStore complex types', 'IntelliSense shows full setStoreWithEffect signature. No red squiggles on function call. Compiled code has no errors', 'Trying to spread SetStoreFunction overloads directly, forgetting that spread cannot infer complex overloads, using never types', 0.88, 'haiku', NOW(), 'https://stackoverflow.com/questions/78209469/how-to-create-a-wrapper-for-solidjss-setstore-in-typescript', 'admin:1764191757'),

('TanStack Query PersistQueryClientProvider memory accumulation on Android with multiple profile data in RAM', 'general', 'MEDIUM', '[{"solution": "Implement manual cache eviction on profile switch: On profile change, use queryClient.invalidateQueries({ queryKey: [prev_user_id, prev_profile_id] }) then queryClient.removeQueries(). For multi-profile apps: Only load current profile''s queries. Persist others to IndexedDB only using persistor.removeClient(profile_id)", "percentage": 88}, {"solution": "Use queryClient.getQueryData to check what''s in memory. Manually clear old profiles with queryClient.setQueryData([user_id, old_profile_id], null) to trigger persistor to store them", "percentage": 82}]'::jsonb, 'React Native/Capacitor with TanStack Query, PersistQueryClientProvider, IndexedDB', 'Only current profile queries in memory. Old profiles'' data in IndexedDB. Chrome DevTools Memory shows <200MB active queries. Profile switch <100ms', 'Keeping all profile queries in memory, not using removeQueries, forgetting persistor stores evicted data, not tracking which profile is active', 0.85, 'haiku', NOW(), 'https://stackoverflow.com/questions/79280396/tanstack-query-persistqueryclientprovider-is-there-a-way-to-remove-certain-q', 'admin:1764191757'),

('Node.js ENOMEM error when spawning child process with child_process.spawn() due to memory exhaustion', 'general', 'MEDIUM', '[{"solution": "Limit concurrent spawned processes. Track live processes and wait for one to finish before spawning next: const running = new Set(); const spawn = (cmd) => { return new Promise((res) => { const proc = child_process.spawn(cmd); running.add(proc); proc.on(''close'', () => { running.delete(proc); res() }) }) }. Or use process pool: piscina or node-worker-threads-pool", "percentage": 90}, {"solution": "Increase available system memory or set process memory limits with --max-old-space-size. Check available RAM: free -h. Spawn less data: process.spawn(cmd, args, { maxBuffer: 10 * 1024 * 1024 }) for large output", "percentage": 75}]'::jsonb, 'Node.js child_process, multiple concurrent spawns, memory-constrained environment', 'Spawning 100+ child processes without errors. Memory stays <2GB. Process pool active <10 processes. No ENOMEM thrown', 'Unbounded spawn calls, not tracking live processes, ignoring maxBuffer, spawning on every request without pooling', 0.87, 'haiku', NOW(), 'https://stackoverflow.com/questions/26193654/node-js-catch-enomem-error-thrown-after-spawn', 'admin:1764191757');
