INSERT INTO knowledge_entries (query, category, type, solutions, executable_type, prerequisites, common_pitfalls, success_indicators, preview_summary, source_url, contributor_email)
VALUES (
  'architecture-patterns - Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design',
  'claude-code',
  'skill',
  '[
    {"solution": "Set up Clean Architecture directory structure", "cli": {"macos": "mkdir -p app/{domain/{entities,value_objects,interfaces},use_cases,adapters/{repositories,controllers,gateways},infrastructure}", "linux": "mkdir -p app/{domain/{entities,value_objects,interfaces},use_cases,adapters/{repositories,controllers,gateways},infrastructure}", "windows": "mkdir -p app/{domain/{entities,value_objects,interfaces},use_cases,adapters/{repositories,controllers,gateways},infrastructure}"}, "manual": "Create folder hierarchy: domain (entities/interfaces), use_cases, adapters (repositories/controllers), infrastructure", "note": "Dependencies flow inward - outer layers depend on inner, never reverse"},
    {"solution": "Implement domain entities with business logic", "cli": {"macos": "cat > app/domain/entities/user.py << ''ENTITY''\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: str\n    email: str\n    name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        self.is_active = False\n\n    def can_place_order(self) -> bool:\n        return self.is_active\nENTITY", "linux": "cat > app/domain/entities/user.py << ''ENTITY''\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: str\n    email: str\n    name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        self.is_active = False\n\n    def can_place_order(self) -> bool:\n        return self.is_active\nENTITY", "windows": "cat > app/domain/entities/user.py << ''ENTITY''\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass User:\n    id: str\n    email: str\n    name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        self.is_active = False\n\n    def can_place_order(self) -> bool:\n        return self.is_active\nENTITY"}, "manual": "Create entity classes in domain/entities with business methods (deactivate, can_place_order). No database or framework code in entities", "note": "Entities contain both data AND behavior - not anemic models"},
    {"solution": "Define port interfaces for repository pattern", "cli": {"macos": "cat > app/domain/interfaces/user_repository.py << ''PORT''\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\nfrom domain.entities.user import User\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def save(self, user: User) -> User:\n        pass\nPORT", "linux": "cat > app/domain/interfaces/user_repository.py << ''PORT''\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\nfrom domain.entities.user import User\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def save(self, user: User) -> User:\n        pass\nPORT", "windows": "cat > app/domain/interfaces/user_repository.py << ''PORT''\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\nfrom domain.entities.user import User\n\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def save(self, user: User) -> User:\n        pass\nPORT"}, "manual": "Create abstract interface classes (ports) in domain/interfaces that define contracts. Implementations come later in adapters", "note": "Ports are technology-agnostic - same interface for PostgreSQL, mock, Redis"},
    {"solution": "Implement use cases for application business logic", "cli": {"macos": "cat > app/use_cases/create_user.py << ''USECASE''\nfrom domain.entities.user import User\nfrom domain.interfaces.user_repository import IUserRepository\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass CreateUserRequest:\n    email: str\n    name: str\n\nclass CreateUserUseCase:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n    async def execute(self, request: CreateUserRequest):\n        existing = await self.user_repository.find_by_email(request.email)\n        if existing:\n            return {\"success\": False, \"error\": \"Email exists\"}\n\n        user = User(\n            id=str(uuid.uuid4()),\n            email=request.email,\n            name=request.name,\n            created_at=datetime.now()\n        )\n        saved = await self.user_repository.save(user)\n        return {\"success\": True, \"user\": saved}\nUSECASE", "linux": "cat > app/use_cases/create_user.py << ''USECASE''\nfrom domain.entities.user import User\nfrom domain.interfaces.user_repository import IUserRepository\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass CreateUserRequest:\n    email: str\n    name: str\n\nclass CreateUserUseCase:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n    async def execute(self, request: CreateUserRequest):\n        existing = await self.user_repository.find_by_email(request.email)\n        if existing:\n            return {\"success\": False, \"error\": \"Email exists\"}\n\n        user = User(\n            id=str(uuid.uuid4()),\n            email=request.email,\n            name=request.name,\n            created_at=datetime.now()\n        )\n        saved = await self.user_repository.save(user)\n        return {\"success\": True, \"user\": saved}\nUSECASE", "windows": "cat > app/use_cases/create_user.py << ''USECASE''\nfrom domain.entities.user import User\nfrom domain.interfaces.user_repository import IUserRepository\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass CreateUserRequest:\n    email: str\n    name: str\n\nclass CreateUserUseCase:\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n    async def execute(self, request: CreateUserRequest):\n        existing = await self.user_repository.find_by_email(request.email)\n        if existing:\n            return {\"success\": False, \"error\": \"Email exists\"}\n\n        user = User(\n            id=str(uuid.uuid4()),\n            email=request.email,\n            name=request.name,\n            created_at=datetime.now()\n        )\n        saved = await self.user_repository.save(user)\n        return {\"success\": True, \"user\": saved}\nUSECASE"}, "manual": "Create use case classes that orchestrate business logic. Inject dependencies (repositories) as constructor parameters. Use cases coordinate between entities and external systems", "note": "Use cases encode application rules - specific to this application, independent of UI/database"},
    {"solution": "Create repository adapters for database implementations", "cli": {"macos": "cat > app/adapters/repositories/postgres_user_repository.py << ''ADAPTER''\nfrom domain.interfaces.user_repository import IUserRepository\nfrom domain.entities.user import User\nfrom typing import Optional\n\nclass PostgresUserRepository(IUserRepository):\n    def __init__(self, pool):\n        self.pool = pool\n\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        async with self.pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM users WHERE id = $1\", user_id)\n            return self._to_entity(row) if row else None\n\n    async def save(self, user: User) -> User:\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"INSERT INTO users (id, email, name, created_at, is_active) VALUES ($1, $2, $3, $4, $5)\",\n                user.id, user.email, user.name, user.created_at, user.is_active\n            )\n        return user\n\n    def _to_entity(self, row) -> User:\n        return User(id=row[0], email=row[1], name=row[2], created_at=row[3], is_active=row[4])\nADAPTER", "linux": "cat > app/adapters/repositories/postgres_user_repository.py << ''ADAPTER''\nfrom domain.interfaces.user_repository import IUserRepository\nfrom domain.entities.user import User\nfrom typing import Optional\n\nclass PostgresUserRepository(IUserRepository):\n    def __init__(self, pool):\n        self.pool = pool\n\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        async with self.pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM users WHERE id = $1\", user_id)\n            return self._to_entity(row) if row else None\n\n    async def save(self, user: User) -> User:\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"INSERT INTO users (id, email, name, created_at, is_active) VALUES ($1, $2, $3, $4, $5)\",\n                user.id, user.email, user.name, user.created_at, user.is_active\n            )\n        return user\n\n    def _to_entity(self, row) -> User:\n        return User(id=row[0], email=row[1], name=row[2], created_at=row[3], is_active=row[4])\nADAPTER", "windows": "cat > app/adapters/repositories/postgres_user_repository.py << ''ADAPTER''\nfrom domain.interfaces.user_repository import IUserRepository\nfrom domain.entities.user import User\nfrom typing import Optional\n\nclass PostgresUserRepository(IUserRepository):\n    def __init__(self, pool):\n        self.pool = pool\n\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        async with self.pool.acquire() as conn:\n            row = await conn.fetchrow(\"SELECT * FROM users WHERE id = $1\", user_id)\n            return self._to_entity(row) if row else None\n\n    async def save(self, user: User) -> User:\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"INSERT INTO users (id, email, name, created_at, is_active) VALUES ($1, $2, $3, $4, $5)\",\n                user.id, user.email, user.name, user.created_at, user.is_active\n            )\n        return user\n\n    def _to_entity(self, row) -> User:\n        return User(id=row[0], email=row[1], name=row[2], created_at=row[3], is_active=row[4])\nADAPTER"}, "manual": "Implement adapters in adapters/ folder that implement port interfaces. Handle database-specific code, ORM, mapping. Keep entities separate from persistence details", "note": "Can swap PostgresUserRepository with MockUserRepository for testing"},
    {"solution": "Define value objects for domain modeling (DDD)", "cli": {"macos": "cat > app/domain/value_objects/email.py << ''VO''\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Email:\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email\")\n\n@dataclass(frozen=True)\nclass Money:\n    amount: int\n    currency: str\n\n    def add(self, other: \"Money\") -> \"Money\":\n        if self.currency != other.currency:\n            raise ValueError(\"Currency mismatch\")\n        return Money(self.amount + other.amount, self.currency)\nVO", "linux": "cat > app/domain/value_objects/email.py << ''VO''\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Email:\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email\")\n\n@dataclass(frozen=True)\nclass Money:\n    amount: int\n    currency: str\n\n    def add(self, other: \"Money\") -> \"Money\":\n        if self.currency != other.currency:\n            raise ValueError(\"Currency mismatch\")\n        return Money(self.amount + other.amount, self.currency)\nVO", "windows": "cat > app/domain/value_objects/email.py << ''VO''\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Email:\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email\")\n\n@dataclass(frozen=True)\nclass Money:\n    amount: int\n    currency: str\n\n    def add(self, other: \"Money\") -> \"Money\":\n        if self.currency != other.currency:\n            raise ValueError(\"Currency mismatch\")\n        return Money(self.amount + other.amount, self.currency)\nVO"}, "manual": "Create immutable value objects using frozen dataclasses. Include validation logic in __post_init__. Value objects represent domain concepts (Money, Email, PhoneNumber)", "note": "Value objects are immutable - equality is by value, not identity"},
    {"solution": "Implement controllers for HTTP layer integration", "cli": {"macos": "cat > app/adapters/controllers/user_controller.py << ''CTRL''\nfrom fastapi import APIRouter, HTTPException\nfrom use_cases.create_user import CreateUserUseCase, CreateUserRequest\nfrom pydantic import BaseModel\n\nrouter = APIRouter()\n\nclass CreateUserDTO(BaseModel):\n    email: str\n    name: str\n\n@router.post(\"/users\")\nasync def create_user(dto: CreateUserDTO, use_case: CreateUserUseCase):\n    request = CreateUserRequest(email=dto.email, name=dto.name)\n    response = await use_case.execute(request)\n    if not response[\"success\"]:\n        raise HTTPException(status_code=400, detail=response[\"error\"])\n    return {\"user\": response[\"user\"]}\nCTRL", "linux": "cat > app/adapters/controllers/user_controller.py << ''CTRL''\nfrom fastapi import APIRouter, HTTPException\nfrom use_cases.create_user import CreateUserUseCase, CreateUserRequest\nfrom pydantic import BaseModel\n\nrouter = APIRouter()\n\nclass CreateUserDTO(BaseModel):\n    email: str\n    name: str\n\n@router.post(\"/users\")\nasync def create_user(dto: CreateUserDTO, use_case: CreateUserUseCase):\n    request = CreateUserRequest(email=dto.email, name=dto.name)\n    response = await use_case.execute(request)\n    if not response[\"success\"]:\n        raise HTTPException(status_code=400, detail=response[\"error\"])\n    return {\"user\": response[\"user\"]}\nCTRL", "windows": "cat > app/adapters/controllers/user_controller.py << ''CTRL''\nfrom fastapi import APIRouter, HTTPException\nfrom use_cases.create_user import CreateUserUseCase, CreateUserRequest\nfrom pydantic import BaseModel\n\nrouter = APIRouter()\n\nclass CreateUserDTO(BaseModel):\n    email: str\n    name: str\n\n@router.post(\"/users\")\nasync def create_user(dto: CreateUserDTO, use_case: CreateUserUseCase):\n    request = CreateUserRequest(email=dto.email, name=dto.name)\n    response = await use_case.execute(request)\n    if not response[\"success\"]:\n        raise HTTPException(status_code=400, detail=response[\"error\"])\n    return {\"user\": response[\"user\"]}\nCTRL"}, "manual": "Create thin controllers in adapters/controllers that handle HTTP/REST concerns only. Delegate business logic to use cases. Map DTOs to request objects", "note": "Controllers should NOT contain business logic - just HTTP protocol handling"}
  ]'::jsonb,
  'steps',
  'Clean Architecture knowledge; Dependency injection pattern; Domain modeling; Abstract interfaces',
  'Putting business logic in controllers; Entities with no behavior (anemic models); Database code in entities; Circular dependencies; Over-engineering simple CRUD; Framework coupling in domain',
  'Directory structure follows Clean Architecture layout; Entities have business methods; Use cases inject dependencies; Adapters implement port interfaces; Controllers are thin',
  'Proven backend patterns (Clean, Hexagonal, DDD) for maintainable, testable systems. Dependency inversion, layered design, domain modeling with value objects and aggregates.',
  'https://skillsmp.com/skills/wshobson-agents-plugins-backend-development-skills-architecture-patterns-skill-md',
  'admin:HAIKU_SKILL_1764289684_93067'
);
