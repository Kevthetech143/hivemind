-- Mining migration for General Deadlock errors
-- Date: 2025-11-26

INSERT INTO knowledge_entries (query, category, hit_frequency, solutions, prerequisites, success_indicators, common_pitfalls, success_rate, claude_version, last_verified, source_url, contributor_email) VALUES

('fatal error: all goroutines are asleep - deadlock', 'general', 'HIGH', '[{"solution": "Use sync.WaitGroup to coordinate goroutines. Ensure all goroutines call wg.Done() and main waits with wg.Wait() before program exits. Producer must close the channel after sending all values.", "percentage": 95}, {"solution": "For range loops over channels, close the channel in the sender goroutine using defer close(ch) to signal no more values will arrive.", "percentage": 90}]'::jsonb, 'Understanding Go concurrency, goroutines, channels, and sync package', 'Program no longer panics with deadlock error, range loop terminates cleanly when channel is closed', 'Forgetting to close channels in receivers, passing WaitGroup by value instead of pointer, not using defer for wg.Done(), main exiting before goroutines finish', 0.92, 'haiku', NOW(), 'https://stackoverflow.com/questions/48865561/solving-goroutines-deadlock', 'admin:1764189866'),

('Two threads wait on each other with circular lock dependency', 'general', 'HIGH', '[{"solution": "Use std::lock() to atomically lock multiple mutexes in a deadlock-safe order. Combine with lock_guard using adopt_lock to manage releases.", "percentage": 96}, {"solution": "Enforce a consistent lock ordering across all code - always lock Mutex1 before Mutex2. Use RAII to ensure mutexes are released.", "percentage": 88}]'::jsonb, 'C++ multithreading knowledge, understanding mutex semantics and RAII patterns', 'Multiple threads can acquire locks without deadlock, exception safety preserved, locks automatically released on scope exit', 'Acquiring locks in different orders in different code paths, forgetting lock_guard scope, improper exception handling in critical sections', 0.94, 'haiku', NOW(), 'https://stackoverflow.com/questions/42720131/multiple-locks-with-mutex-and-the-possibility-of-a-deadlock', 'admin:1764189866'),

('Passing sync.WaitGroup by value to goroutines causes deadlock', 'general', 'HIGH', '[{"solution": "Pass sync.WaitGroup as a pointer (*sync.WaitGroup) to goroutines, not by value. This ensures wg.Done() updates the original counter.", "percentage": 97}, {"solution": "Declare WaitGroup globally to make it accessible from all functions without passing parameters.", "percentage": 85}]'::jsonb, 'Go pointer semantics, goroutine creation, sync package usage', 'Goroutines correctly decrement WaitGroup counter, wg.Wait() returns instead of hanging indefinitely', 'Forgetting the pointer dereference when passing to goroutine, declaring WaitGroup inside main() without passing as pointer, not using defer wg.Done()', 0.98, 'haiku', NOW(), 'https://stackoverflow.com/questions/37183651/go-program-getting-deadlock', 'admin:1764189866'),

('APPARENT DEADLOCK triggered when thread pool tasks remain blocked', 'general', 'MEDIUM', '[{"solution": "Set c3p0.statementCacheNumDeferredCloseThreads=1 to ensure Statement.close() operations happen on separate thread pool.", "percentage": 92}, {"solution": "Increase c3p0.maxPoolSize and c3p0.acquireIncrement to provide more available threads for pending tasks.", "percentage": 75}]'::jsonb, 'C3P0 connection pool configuration, JDBC driver knowledge, understanding thread pool deadlock detection', 'ThreadPoolAsynchronousRunner no longer reports APPARENT DEADLOCK, cached statement tasks complete successfully, thread pool recovers gracefully', 'Using JDBC drivers with non-compliant Statement.close() behavior, insufficient pool size for concurrent load, ignoring deadlock detector warnings', 0.88, 'haiku', NOW(), 'https://stackoverflow.com/questions/58283321/understanding-apparent-deadlock-complete-status-details', 'admin:1764189866'),

('for range over channel deadlock when channel not closed', 'general', 'HIGH', '[{"solution": "Close the channel after all values are sent using defer close(ch) in the sender goroutine. for range loop will terminate on closed channel.", "percentage": 94}, {"solution": "Use buffered channels with explicit receiver count tracking, but prefer closing channels for cleaner semantics.", "percentage": 70}]'::jsonb, 'Go channel semantics, understanding for range termination conditions, goroutine synchronization patterns', 'for range loop exits cleanly, no hanging on blocked receives, clean shutdown without deadlock panic', 'Forgetting to close channels, assuming range will terminate without close, mixing buffered/unbuffered channel expectations', 0.93, 'haiku', NOW(), 'https://stackoverflow.com/questions/67422322/go-range-over-channel-deadlock-problems-should-i-close-the-channel', 'admin:1764189866'),

('Multiple producers without synchronization creating channel deadlock', 'general', 'HIGH', '[{"solution": "Create a coordinator that uses sync.WaitGroup to track all producers. Coordinator waits for all producers to finish, then closes the channel.", "percentage": 93}, {"solution": "Use a separate goroutine to wait for all producers with WaitGroup, then close channel in that goroutine.", "percentage": 89}]'::jsonb, 'Go concurrency patterns, sync.WaitGroup, channel closing responsibility, producer-consumer pattern', 'All values from all producers received, channel closes cleanly, no deadlock with multiple concurrent producers', 'Attempting to close channel from multiple producers simultaneously, closing channel before all values sent, unclear producer coordination', 0.90, 'haiku', NOW(), 'https://stackoverflow.com/questions/48865561/solving-goroutines-deadlock', 'admin:1764189866'),

('Recursive mutex with same thread locking multiple times', 'general', 'MEDIUM', '[{"solution": "Use std::recursive_mutex instead of std::mutex to allow same thread to acquire lock multiple times. Unlock must match lock count.", "percentage": 94}, {"solution": "Track lock owner thread ID and allow same thread to reacquire while blocking other threads. Increment counter on each lock.", "percentage": 88}]'::jsonb, 'C++ recursive mutex semantics, understanding lock counts, thread ID tracking', 'Same thread can acquire lock multiple times without deadlock, lock count properly tracked, all locks released on corresponding unlocks', 'Using std::mutex when recursive locking needed, forgetting to unlock matching number of times, confusion about recursive vs regular mutex', 0.91, 'haiku', NOW(), 'https://stackoverflow.com/questions/50006957/will-recursive-mutex-deadlock-when-locked-by-2-threads', 'admin:1764189866'),

('Mutex lock not released in exception path causing thread deadlock', 'general', 'HIGH', '[{"solution": "Use RAII pattern with lock_guard<mutex> or unique_lock<mutex> to ensure unlock() is called even if exception occurs.", "percentage": 97}, {"solution": "Always use try-lock with proper exception handling and manual unlock in catch blocks for non-RAII approaches.", "percentage": 78}]'::jsonb, 'C++ RAII principles, exception handling, lock_guard and unique_lock semantics, exception safety guarantees', 'Mutexes automatically released on exception, no hanging threads, exception propagation works correctly with locked resources', 'Forgetting to unlock in exception handlers, using manual lock/unlock without try-catch, relying on function return to unlock', 0.95, 'haiku', NOW(), 'https://stackoverflow.com/questions/3045066/permanent-mutex-locking-causing-deadlock', 'admin:1764189866'),

('Consumer waiting on empty channel with no sender causes deadlock', 'general', 'HIGH', '[{"solution": "Ensure sender goroutine writes to same channel that consumer reads from. Verify channels are not accidentally different instances.", "percentage": 96}, {"solution": "Implement timeout on channel read operations using select with time.After() to prevent indefinite blocking.", "percentage": 82}]'::jsonb, 'Go channel basics, goroutine synchronization, understanding blocking channel operations, select statement with timeouts', 'Consumer receives values from sender, no indefinite hangs, proper timeout handling for stuck receives', 'Passing different channel instances to sender/receiver, forgetting to pass channel to goroutine, buffering mismatch', 0.93, 'haiku', NOW(), 'https://stackoverflow.com/questions/49766629/all-channels-are-deadlocked', 'admin:1764189866'),

('Thread holds lock and waits for resource held by locked thread', 'general', 'HIGH', '[{"solution": "Release locks before blocking on I/O or external resources. Use hand-over-hand locking pattern for sequential acquisitions.", "percentage": 91}, {"solution": "Use timeouts on lock acquisition and waiting operations to detect potential deadlock scenarios early.", "percentage": 80}]'::jsonb, 'Lock ordering discipline, understanding resource hierarchies, deadlock prevention patterns, timeout mechanisms', 'Threads can make progress while other threads wait, no circular wait conditions, proper lock release before blocking operations', 'Holding locks during I/O operations, nested lock acquisition without careful ordering, blocking inside critical sections', 0.87, 'haiku', NOW(), 'https://stackoverflow.com/questions/2774935/what-is-a-deadlock-in-a-database', 'admin:1764189866');
