-- Mine Stack Overflow: Top 12 Highest Voted Python Questions with Accepted Answers
-- Source: https://stackoverflow.com/questions/tagged/python?tab=votes
-- Category: stackoverflow-python
-- Batch 1: Questions 1-12

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, last_verified, source_url
) VALUES
(
    'What does the yield keyword do in Python?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "The yield keyword transforms a function into a generator function. When called, it returns a generator object (lazy iterator) that produces values on-demand rather than storing them all in memory. Code executes only when you request the next value via a for loop or next() call.", "percentage": 95, "note": "Generators implement Python''s iterator protocol (__iter__ and __next__)"},
        {"solution": "Instead of return [1,2,3] which creates entire list in memory, use yield 1; yield 2; yield 3 to generate values incrementally. The function execution pauses at each yield, remembering position and variables.", "percentage": 90, "command": "def get_values():\n    yield 1\n    yield 2\n    yield 3\nfor val in get_values(): print(val)"},
        {"solution": "Use generators for large datasets - much more memory-efficient than returning complete lists. Compatible with for loops, list comprehensions, and functions expecting iterables.", "percentage": 88, "note": "State preservation allows resuming execution from suspended yield point"}
    ]'::jsonb,
    'Basic understanding of functions and loops, Python 2.3+',
    'Generator object created successfully, Values produced on iteration without loading all in memory, Code in generator body executes only when iterating',
    'Confusing yield with return - yield does not return and exit the function immediately. Expecting all values in memory when using generators.',
    0.92,
    NOW(),
    'https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python'
),
(
    'What does if __name__ == "__main__": do?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "When Python runs a file directly, __name__ is set to \"__main__\". When the same file is imported as a module, __name__ contains the module''s name. This idiom controls when code executes.", "percentage": 95, "note": "Enables code to function both as standalone script and importable module"},
        {"solution": "Use this pattern to prevent unintended execution when another script imports your code. Wrap execution logic in main() function inside the if block.", "percentage": 92, "command": "def main():\n    # Your code here\n    pass\n\nif __name__ == \"__main__\":\n    main()"},
        {"solution": "Without the guard, importing a module executes all top-level code. With the if-block, the code is available for import without automatic execution.", "percentage": 90, "note": "Best practice: always use this pattern for scripts with importable functions"}
    ]'::jsonb,
    'Basic Python script structure, Understanding of imports',
    'Code in if-block executes when running script directly, Code skipped when module is imported, Module functions available for import without side effects',
    'Forgetting to use this guard when writing modules with executable code. Not wrapping execution logic in a main() function.',
    0.94,
    NOW(),
    'https://stackoverflow.com/questions/419163/what-does-if-name-main-do'
),
(
    'Does Python have a ternary conditional operator?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "Yes, Python has a ternary conditional operator with syntax: a if condition else b. The condition is evaluated first. If True, a is evaluated and returned; otherwise b is evaluated and returned.", "percentage": 96, "note": "Must always provide else clause, unlike some languages"},
        {"solution": "Use short-circuit evaluation: when condition is true, only a is evaluated (not b), and vice versa. This is more efficient than alternative approaches.", "percentage": 93, "command": "result = ''true'' if condition else ''false''\nreturn a if condition else b"},
        {"solution": "Remember that else is mandatory in Python. You cannot use statements like pass or assignments within ternary: x = 1 if False else y = 2 causes SyntaxError.", "percentage": 88, "note": "Added in Python 2.5; prior versions used unreliable workarounds"}
    ]'::jsonb,
    'Python 2.5+, Basic understanding of conditionals',
    'Ternary expression evaluates correctly, Returns expected value for true/false conditions, Code compiles without SyntaxError',
    'Trying to omit the else clause. Attempting to use statements instead of expressions. Forgetting that stop is exclusive in slicing.',
    0.94,
    NOW(),
    'https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator'
),
(
    'What are metaclasses in Python?',
    'stackoverflow-python',
    'HIGH',
    '[
        {"solution": "A metaclass is the class of a class - it defines how a class behaves, just as a class defines how instances behave. The primary metaclass is type, which is itself a class and its own metaclass.", "percentage": 94, "note": "Classes are objects that can be assigned to variables and passed as parameters"},
        {"solution": "When Python encounters a class statement, it creates an object (the class) using a metaclass. You can create classes manually using type(name, bases, attrs) with three arguments: name (class name), bases (parent classes tuple), attrs (class attributes dict).", "percentage": 91, "command": "MyClass = type(''MyClass'', (), {})\n# Equivalent to: class MyClass(object): pass"},
        {"solution": "Create custom metaclass by subclassing type and implementing __new__() to customize class creation. Common use cases: creating framework APIs like Django ORM that intercept class creation to add special behavior automatically.", "percentage": 87, "note": "Advanced feature mostly for framework developers"}
    ]'::jsonb,
    'Understanding of Python classes and object model, Python 2.2+',
    'Custom metaclass successfully intercepts class creation, Class attributes modified as intended, Framework API behavior works correctly',
    'Over-complicating code with metaclasses when simpler approaches exist. Using metaclasses for things that decorators or class inheritance can handle.',
    0.89,
    NOW(),
    'https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python'
),
(
    'How do I check whether a file exists without exceptions?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "Use os.path.isfile(fname) to check if path refers to existing regular file. For directories or any path type, use os.path.exists().", "percentage": 94, "command": "import os.path\nos.path.isfile(fname)  # True if file exists\nos.path.exists(fname)  # True for files or directories"},
        {"solution": "Modern Python 3.4+ approach using pathlib: from pathlib import Path; my_file = Path(\"/path/to/file\"); if my_file.is_file() or if my_file.is_dir() or if my_file.exists()", "percentage": 92, "command": "from pathlib import Path\nmy_file = Path(\"/path/to/file\")\nif my_file.is_file():\n    # file exists"},
        {"solution": "Important caveat: if checking to perform action like ''if file_exists: open_it()'', safer to use try/except around open attempt due to race conditions. File may be deleted between check and use.", "percentage": 85, "note": "EAFP (Easier to Ask for Forgiveness than Permission) is more Pythonic"}
    ]'::jsonb,
    'Python 2.x or 3.x, File system access permissions',
    'File existence check returns correct boolean, No exceptions raised, Race condition handled properly in critical sections',
    'Relying on existence check before file operations without exception handling. Using os.path.exists() when specifically checking for files.',
    0.91,
    NOW(),
    'https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions'
),
(
    'How do I merge two dictionaries in a single expression in Python?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "Python 3.9+: Use merge operator z = x | y. For Python 3.5-3.8: Use dictionary unpacking z = {**x, **y}. For Python 2 and 3.0-3.4: Create merge function with copy() and update().", "percentage": 95, "command": "# Python 3.9+\nz = x | y\n\n# Python 3.5+\nz = {**x, **y}\n\n# Python 2/3.0-3.4\nz = x.copy()\nz.update(y)"},
        {"solution": "When merging with overlapping keys, second dictionary''s values take precedence: x = {''a'': 1, ''b'': 2}; y = {''b'': 3, ''c'': 4}; z = {**x, **y} results in {''a'': 1, ''b'': 3, ''c'': 4}", "percentage": 93, "note": "Second dict values override first dict values for duplicate keys"},
        {"solution": "Performance note: unpacking syntax {**x, **y} and | operator significantly faster than alternatives like dict(list(x.items()) + list(y.items())) which creates unnecessary intermediate lists.", "percentage": 88, "note": "Avoid list concatenation approaches for performance-critical code"}
    ]'::jsonb,
    'Python 2.7+, Two dictionaries to merge',
    'Merged dictionary contains all keys from both sources, Overlapping keys have values from second dictionary, Result is new dictionary (originals unchanged)',
    'Using slow list concatenation methods. Not accounting for overlapping keys. Using mutable update without understanding it modifies in-place.',
    0.93,
    NOW(),
    'https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python'
),
(
    'How do I execute a program or call a system command?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "Use subprocess.run() as modern standard for executing external commands: import subprocess; subprocess.run([\"ls\", \"-l\"]). Pass command as list of separate arguments, not string.", "percentage": 95, "command": "import subprocess\nsubprocess.run([\"ls\", \"-l\"])\n# For older Python 3.4 and earlier: subprocess.call([\"ls\", \"-l\"])"},
        {"solution": "subprocess.run() is preferable to os.system because it offers: safer handling of external sources, better stdout/stderr capture, improved error handling and return code detection.", "percentage": 92, "note": "Never use os.system for security-sensitive operations"},
        {"solution": "CRITICAL SECURITY: Never use shell=True with untrusted input or user-provided data. Command injection risk if using string interpolation. Always construct commands as lists of separate arguments to prevent injection attacks.", "percentage": 90, "note": "String concatenation with user input + shell=True = vulnerability"}
    ]'::jsonb,
    'Python 2.7+, Target command/program installed and accessible, subprocess module imported',
    'External program executes successfully, Return codes properly captured, Stdout/stderr redirected as intended',
    'Using os.system() for security-sensitive operations. Using shell=True with untrusted input. Passing command as single concatenated string instead of list.',
    0.91,
    NOW(),
    'https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command'
),
(
    'How do I create a directory and any missing parent directories?',
    'stackoverflow-python',
    'HIGH',
    '[
        {"solution": "Python 3.5+: Use pathlib.Path.mkdir(parents=True, exist_ok=True). Recursively creates all missing parent directories and doesn''t raise exception if directory already exists.", "percentage": 95, "command": "from pathlib import Path\nPath(\"/my/directory\").mkdir(parents=True, exist_ok=True)"},
        {"solution": "Python 3.2-3.4: Use os.makedirs(\"path/to/directory\", exist_ok=True). For Python 2.7: Use try/except with errno.EEXIST to handle race conditions where another process creates directory between check and creation.", "percentage": 93, "command": "import os\nos.makedirs(\"path/to/directory\", exist_ok=True)\n\n# Python 2.7:\nimport errno\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise"},
        {"solution": "Note that os.path.exists() returns True for both directories and files. Use os.path.isdir() for more precise validation if needed.", "percentage": 88, "note": "pathlib approach is more modern and recommended"}
    ]'::jsonb,
    'Python 2.7+, File system write permissions for parent directories',
    'Directory created successfully with all parents, No exception raised for existing directory, Correct directory structure visible on filesystem',
    'Using os.path.exists() which doesn''t distinguish between files and directories. Not handling race conditions in Python 2.7. Forgetting exist_ok=True causing exceptions.',
    0.92,
    NOW(),
    'https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories'
),
(
    'How can I access the index value in a for loop?',
    'stackoverflow-python',
    'VERY_HIGH',
    '[
        {"solution": "Use Python''s built-in enumerate() function as most Pythonic approach: for idx, x in enumerate(xs): print(idx, x). Unpacks each iteration into both index and value.", "percentage": 96, "command": "for idx, x in enumerate([''a'', ''b'', ''c'']):\n    print(idx, x)  # 0 a, 1 b, 2 c"},
        {"solution": "Adjust starting index if needed: for idx, x in enumerate(xs, start=1) starts counting from 1 instead of 0. Function is heavily optimized at C level for performance.", "percentage": 94, "command": "for idx, x in enumerate(xs, start=1):\n    print(idx, x)  # 1, 2, 3..."},
        {"solution": "Avoid non-Pythonic approach: for i in range(len(items)): print(i, items[i]). While functional, this requires explicit indexing and is considered inefficient and unreadable compared to enumerate().", "percentage": 89, "note": "enumerate() is standard recommended way since Python 2.3"}
    ]'::jsonb,
    'Python 2.3+, Iterable sequence (list, tuple, string, etc.)',
    'Index and value both accessible in loop, enumerate() returns correct sequence of (index, value) tuples, Custom start parameter works correctly',
    'Using range(len()) approach instead of enumerate(). Not using start parameter when 1-based indexing is needed. Manually tracking counters.',
    0.95,
    NOW(),
    'https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop'
),
(
    'How do I make a flat list out of a list of lists?',
    'stackoverflow-python',
    'HIGH',
    '[
        {"solution": "Use nested list comprehension as fastest and most Pythonic approach: flat_list = [x for xs in xss for x in xs]. Equivalent to nested for loops but generates one list once.", "percentage": 95, "command": "xss = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nflat_list = [x for xs in xss for x in xs]\n# Result: [1, 2, 3, 4, 5, 6, 7, 8, 9]"},
        {"solution": "Alternative using itertools.chain: import itertools; merged = list(itertools.chain.from_iterable(xss)). Actually faster in practice but less intuitive for beginners.", "percentage": 92, "command": "import itertools\nflat = list(itertools.chain.from_iterable(xss))"},
        {"solution": "AVOID sum(xss, []) or reduce() approaches which involve repeated list concatenation with O(L²) complexity and poor performance for large datasets. List comprehension copies each item exactly once with O(L) complexity.", "percentage": 88, "note": "List concatenation in loops creates new list each iteration"}
    ]'::jsonb,
    'Python 2.x or 3.x, List of lists/iterables structure',
    'All nested items flattened into single list, Original structure preserved/modified as intended, Performance optimal for dataset size',
    'Using sum(xss, []) which has terrible O(L²) performance. Using reduce() with concatenation. Not considering performance implications of different approaches.',
    0.93,
    NOW(),
    'https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists'
),
(
    'What is the difference between @staticmethod and @classmethod in Python?',
    'stackoverflow-python',
    'HIGH',
    '[
        {"solution": "@classmethod receives the class as first argument (cls), @staticmethod receives no implicit first argument. Instance methods receive the instance (self).", "percentage": 95, "command": "class A:\n    def foo(self, x):\n        print(f\"instance method: {self}, {x}\")\n    \n    @classmethod\n    def class_foo(cls, x):\n        print(f\"class method: {cls}, {x}\")\n    \n    @staticmethod\n    def static_foo(x):\n        print(f\"static method: {x}\")"},
        {"solution": "Use @classmethod when method needs to access or modify class-level state, or when creating factory methods that work correctly with inheritance. Classmethod works on class directly: A.class_foo(1)", "percentage": 92, "note": "Classmethods receive class object, enabling inheritance-aware factories"},
        {"solution": "Use @staticmethod when method logically belongs with class but doesn''t require access to class or instance data - essentially a utility function grouped with related code. Staticmethod receives no self/cls.", "percentage": 91, "note": "Staticmethod is just function namespaced inside class"}
    ]'::jsonb,
    'Python 2.2+, Understanding of instance/class concepts',
    '@classmethod receives correct cls argument in inheritance, @staticmethod ignores implicit arguments, Factory methods return correct subclass instances',
    'Confusing which decorator to use. Using classmethod when staticmethod appropriate. Using instance methods when class/static methods needed. Forgetting cls vs self distinction.',
    0.92,
    NOW(),
    'https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python'
),
(
    'How slicing in Python works',
    'stackoverflow-python',
    'HIGH',
    '[
        {"solution": "Python slicing uses syntax a[start:stop:step] where: stop is EXCLUSIVE (first value NOT included), negative indices count from end, default step is 1.", "percentage": 95, "command": "a = [0, 1, 2, 3, 4, 5]\na[:]           # entire sequence [0,1,2,3,4,5]\na[start:]      # from start to end\na[:stop]       # from beginning through stop-1\na[start:stop:step]  # with custom step\na[::-1]        # reversed [5,4,3,2,1,0]\na[-2:]         # last two items [4,5]\na[:-2]         # everything except last two [0,1,2,3]"},
        {"solution": "Slicing notation a[start:stop:step] is equivalent to using slice() object: a[slice(start, stop, step)]. Useful for programmatic slice generation using None to skip parameters.", "percentage": 92, "command": "a[0:2]  # Same as:\na[slice(0, 2, None)]  # Elements at indices 0 and 1, not 2"},
        {"solution": "Key insight: think of indices as pointing BETWEEN elements rather than at them. This explains why a[0:2] includes positions 0 and 1 but not 2. The difference between stop and start equals the number of selected elements (if step is 1).", "percentage": 90, "note": "Most common mistake: forgetting stop is exclusive"}
    ]'::jsonb,
    'Python 2.x or 3.x, Basic understanding of sequences (lists, strings, tuples)',
    'Slice returns correct subset of sequence, Negative indices work correctly, Step parameter produces expected interval, Stop-exclusive behavior confirmed',
    'Thinking stop is inclusive instead of exclusive. Forgetting negative indices count from end. Misunderstanding step parameter direction. Confusing slice semantics.',
    0.94,
    NOW(),
    'https://stackoverflow.com/questions/509211/how-slicing-in-python-works'
);
