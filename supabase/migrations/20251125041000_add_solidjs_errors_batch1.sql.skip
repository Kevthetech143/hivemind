-- Add SolidJS common errors and gotchas batch 1
-- Source: https://docs.solidjs.com/concepts/intro-to-reactivity, effects, stores, and fine-grained-reactivity guides

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'SolidJS: Signal accessed outside tracking scope does not update',
    'solidjs',
    'VERY_HIGH',
    '[
        {"solution": "Place signal access inside a tracking scope like JSX templates or createEffect callbacks", "percentage": 95, "note": "Only template expressions and effects track dependencies"},
        {"solution": "Use createEffect to create implicit tracking scope for side effects dependent on signals", "percentage": 90, "command": "createEffect(() => { console.log(count()) })"},
        {"solution": "Access signals in JSX templates which automatically create tracking scopes", "percentage": 95, "note": "JSX expressions are the primary tracking context"}
    ]'::jsonb,
    'SolidJS project set up, signal created with createSignal',
    'Signal changes trigger component re-render, createEffect callback re-runs when signal changes',
    'Accessing signals at component root level or outside JSX/effects will not track changes. Do not expect top-level variable access to be reactive.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/intro-to-reactivity'
),
(
    'SolidJS: Component function only runs once, does not re-execute on signal changes',
    'solidjs',
    'VERY_HIGH',
    '[
        {"solution": "Use createEffect for side effects that should re-run when dependencies change", "percentage": 95, "note": "Components execute once during initialization only"},
        {"solution": "Place reactive code in JSX return statements to create implicit tracking", "percentage": 90, "note": "JSX expressions re-evaluate when tracked signals change"},
        {"solution": "Use createMemo for derived computations that need re-calculation on dependency changes", "percentage": 85, "note": "Memos cache and only recalculate when dependencies change"}
    ]'::jsonb,
    'SolidJS component with signals, expectation of reactive re-execution',
    'Side effects run when dependencies change, derived values update correctly in templates',
    'Expecting component function body to re-run like in React. SolidJS components execute once; reactivity comes from effects and templates.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/intro-to-reactivity'
),
(
    'SolidJS: Forgetting to call signal getter returns function object instead of value',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Always invoke signals with parentheses: count() not count", "percentage": 95, "note": "Signals are getter/setter functions"},
        {"solution": "Use linter rules or TypeScript to catch missing parentheses", "percentage": 85, "command": "eslint with solidjs-rules or use strict TypeScript types"},
        {"solution": "Remember signals are not plain values; they must be called to read current value", "percentage": 90, "note": "This differs from useState in React which returns [value, setter]"}
    ]'::jsonb,
    'SolidJS project with createSignal, developer unfamiliar with signal pattern',
    'Template correctly displays signal value, no "[Function]" appearing in rendered output',
    'Using signal name directly without parentheses will show [Function] or cause type errors. Always use signal() syntax to read value.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/intro-to-reactivity'
),
(
    'SolidJS: Multiple async signal updates trigger separate reactive updates instead of batching',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Use batch() utility to group multiple signal updates into single notification", "percentage": 95, "note": "batch delays updates until all signal calls complete"},
        {"solution": "Import batch from solidjs: import { batch } from \"solid-js\"", "percentage": 95, "command": "batch(() => { setCount(1); setName(\"John\"); })"},
        {"solution": "Wrap async operations that update multiple signals in batch for consistency", "percentage": 90, "note": "Prevents inconsistent intermediate states from triggering effects multiple times"}
    ]'::jsonb,
    'SolidJS project with multiple signal updates in async context',
    'Effects run once after all batched updates complete, no intermediate state updates visible',
    'Multiple async signal updates trigger separate effect runs. Use batch() to ensure single atomic update notification.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/intro-to-reactivity'
),
(
    'SolidJS: Setting signals inside createEffect causes infinite loops or redundant renders',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Use createMemo instead of createEffect for computed values", "percentage": 95, "note": "Memos are designed for derived state, effects for side effects"},
        {"solution": "If effect must update signals, use untrack() to break dependency cycle", "percentage": 85, "command": "createEffect(() => { setDerived(untrack(() => count() * 2)) })"},
        {"solution": "Remember effects are for side effects only, not for computing reactive state", "percentage": 90, "note": "Setting signals in effects violates reactive pattern and causes loops"}
    ]'::jsonb,
    'SolidJS project with createEffect attempting to derive and set new signals',
    'Derived values update without infinite loops, component renders efficiently',
    'Effects trigger when they set signals they depend on, creating infinite loops. Use memos for computations, effects for side effects only.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/effects'
),
(
    'SolidJS: createEffect runs on initialization even when dependencies should prevent it',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Use onMount lifecycle hook for code that should only run once on component initialization", "percentage": 95, "note": "onMount is specifically for single initialization runs"},
        {"solution": "For effects that skip initial run, wrap initial state in mutable ref to prevent tracking", "percentage": 80, "note": "Advanced pattern using untrack for initial setup"},
        {"solution": "Understand effects always execute once; design accordingly or use onMount alternative", "percentage": 90, "note": "This is documented guarantee of effect execution model"}
    ]'::jsonb,
    'SolidJS component using createEffect expecting single execution',
    'Initialization code runs once, subsequent signal changes trigger effect correctly',
    'createEffect runs immediately even without dependency changes. Effects always run once on creation. Use onMount for true single-execution initialization.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/effects'
),
(
    'SolidJS: Store properties not reactive until accessed within tracking scope',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Wrap all store property access in createEffect or JSX templates for reactivity", "percentage": 95, "note": "Lazy signal creation requires tracking scope for subscriptions"},
        {"solution": "Use createEffect to establish dependency tracking for store reads", "percentage": 90, "command": "createEffect(() => { console.log(store.users.at(-1)) })"},
        {"solution": "Access store in JSX templates which automatically create tracking context", "percentage": 95, "note": "Template expressions provide implicit tracking scope"}
    ]'::jsonb,
    'SolidJS store created with createStore, store values updated',
    'Store changes trigger re-renders when accessed in effects or templates, not in top-level code',
    'Accessing store outside tracking scopes (console.log at root) won''t establish subscriptions. Always wrap store access in effects or templates.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/stores'
),
(
    'SolidJS: Array spread operator vs path syntax in stores have different reactivity impacts',
    'solidjs',
    'MEDIUM',
    '[
        {"solution": "Use spread operator when you need all dependent effects to re-run on array change", "percentage": 90, "note": "setStore(\"users\", u => [...u, newUser]) treats array as new", "command": "setStore(\"users\", (otherUsers) => [...otherUsers, newUser])"},
        {"solution": "Use path syntax for targeted updates when only specific index should trigger reruns", "percentage": 85, "note": "setStore(\"users\", index, newUser) updates efficiently without full array reactivity", "command": "setStore(\"users\", store.users.length, newUser)"},
        {"solution": "Choose based on needed reactivity scope: full array changes vs specific index", "percentage": 80, "note": "Performance and reactivity behavior differs significantly"}
    ]'::jsonb,
    'SolidJS store with array property, multiple dependent effects',
    'Array updates trigger appropriate level of reactivity without unnecessary re-renders',
    'Spread operator creates new array triggering full reactivity; path syntax targets specific indices. Wrong choice causes inefficient or incomplete updates.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/stores'
),
(
    'SolidJS: Async operations in effects don''t automatically track signal dependencies',
    'solidjs',
    'HIGH',
    '[
        {"solution": "Use createResource for async data fetching with automatic dependency tracking", "percentage": 95, "note": "createResource handles async patterns correctly"},
        {"solution": "For manual async handling, access signals before setTimeout/async call in synchronous context", "percentage": 85, "note": "Register dependencies before entering async scope"},
        {"solution": "Use on() utility for manual dependency specification in async contexts", "percentage": 80, "command": "createEffect(on(() => userId(), async (id) => { /* fetch */ }))"},
        {"solution": "Understand async callbacks lose automatic subscriber registration when executed later", "percentage": 85, "note": "System doesn''t wait for async completion"}
    ]'::jsonb,
    'SolidJS effect with setTimeout or async/await accessing signals',
    'Async operations complete and update UI correctly without stale closures or missing dependencies',
    'Signals accessed in async callbacks (setTimeout, promises) won''t track as effect dependencies. Async operations exit synchronous tracking context.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/advanced-concepts/fine-grained-reactivity'
),
(
    'SolidJS: Conditional signal reads in memos are not tracked if condition is false',
    'solidjs',
    'MEDIUM',
    '[
        {"solution": "Ensure all potentially needed signals are accessed in tracked scope even if conditional", "percentage": 85, "note": "Memo only tracks signals actually read during execution"},
        {"solution": "Use createEffect with on() for manual dependency specification if conditions prevent reads", "percentage": 80, "command": "createEffect(on(() => [count(), enabled()], () => { /* */ }))"},
        {"solution": "Understand that memos only track dependencies that execute; skipped reads aren''t tracked", "percentage": 90, "note": "This is correct fine-grained behavior but can surprise developers"}
    ]'::jsonb,
    'SolidJS memo with conditional signal access, signal changes when condition is false',
    'Memo correctly recalculates only when actually-read signals change, not unnecessarily',
    'Signals in conditionals that don''t execute aren''t tracked by memos. Changes to unread signals won''t trigger updates.',
    0.86,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/advanced-concepts/fine-grained-reactivity'
),
(
    'SolidJS: Effects execution order not guaranteed when multiple effects or signals update',
    'solidjs',
    'MEDIUM',
    '[
        {"solution": "Do not rely on specific effect execution order; design effects to be independent", "percentage": 95, "note": "Order is documented as unpredictable"},
        {"solution": "Use batch() to coordinate multiple dependent updates and ensure consistent state", "percentage": 85, "note": "Batch ensures all updates complete before effects re-run"},
        {"solution": "Structure effects to handle any order of execution; avoid dependencies on other effects", "percentage": 90, "note": "This is a fundamental design principle of fine-grained reactivity"}
    ]'::jsonb,
    'SolidJS with multiple createEffect calls dependent on same signals',
    'Component behaves correctly regardless of effect execution sequence',
    'Do not assume effects execute in definition order. Multiple effects on same signal have unpredictable order. Design for independence.',
    0.87,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/effects'
),
(
    'SolidJS: Object properties shallow merged instead of replaced when set in store',
    'solidjs',
    'MEDIUM',
    '[
        {"solution": "Understand setStore shallow merges objects; only changed properties need to be set", "percentage": 95, "note": "setStore(\"user\", 0, { id: 109 }) preserves other properties"},
        {"solution": "Use this behavior to your advantage for partial updates without full replacement", "percentage": 90, "note": "Shallow merge is convenient for updating subsets of object properties"},
        {"solution": "If full replacement needed, explicitly clear all properties before setting", "percentage": 75, "note": "Usually shallow merge is preferred; full replacement is less common"}
    ]'::jsonb,
    'SolidJS store with nested objects, updating subset of object properties',
    'Object updates only change specified properties, other properties preserved',
    'setStore automatically shallow merges objects. Setting {id: 109} keeps other properties. Not a full replacement like plain variable assignment.',
    0.85,
    'sonnet-4',
    NOW(),
    'https://docs.solidjs.com/concepts/stores'
);
