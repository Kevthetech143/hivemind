INSERT INTO knowledge_entries (query, category, hit_frequency, solutions, prerequisites, success_indicators, common_pitfalls, success_rate, claude_version, last_verified, source_url, contributor_email) VALUES
('useState set method not reflecting a change immediately', 'react', 'HIGH', '[{"solution": "State updates are asynchronous - use useEffect to perform actions after state changes: useEffect(() => { /* do something */ }, [stateVariable])", "percentage": 95}, {"solution": "State values are immutable in closures - if you need current value immediately after setState, use useEffect with dependency array", "percentage": 90}, {"solution": "For immediate synchronous access, use useRef instead of useState", "percentage": 85}]'::jsonb, 'React 16.8+, JavaScript closures', 'Component re-renders with updated state', 'Attempting to console.log state immediately after setState, expecting synchronous update', 0.92, 'haiku', NOW(), 'https://stackoverflow.com/questions/54069253', 'admin:1764194183'),
('useEffect infinite loop with object or array dependencies', 'react', 'HIGH', '[{"solution": "Pass empty dependency array [] if effect should run only once on mount", "percentage": 96}, {"solution": "Use proper dependency tracking: useEffect(() => { /* effect */ }, [dependency]) instead of [obj] for objects", "percentage": 94}, {"solution": "Clone objects/arrays before state updates: const newObj = JSON.parse(JSON.stringify(old)); setObj(newObj)", "percentage": 88}]'::jsonb, 'React Hooks, useState, useEffect', 'Effect runs exactly once on mount', 'Passing object or array in dependency array causes infinite loop because reference changes even if content is same', 0.91, 'haiku', NOW(), 'https://stackoverflow.com/questions/53070970', 'admin:1764194183'),
('useEffect runs continuously forever without dependency array', 'react', 'VERY_HIGH', '[{"solution": "Always provide empty dependency array for mount-only effects: useEffect(() => { /* code */ }, [])", "percentage": 97}, {"solution": "Include all state variables used in effect in dependency array to control re-runs", "percentage": 96}, {"solution": "Use useCallback to memoize functions passed as dependencies", "percentage": 89}]'::jsonb, 'React 16.8+, useEffect hook', 'Effect runs exactly once when component mounts', 'Missing or incomplete dependency array causes effect to run on every render, creating infinite loop if state is updated in effect', 0.94, 'haiku', NOW(), 'https://stackoverflow.com/questions/53243203', 'admin:1764194183'),
('Component loses state on re-render when rendering conditionally', 'react', 'HIGH', '[{"solution": "Lift state up to common parent component - move state from child to parent and pass as props", "percentage": 93}, {"solution": "Use key prop consistently on components: <Component key={stableId} /> to preserve state identity", "percentage": 91}, {"solution": "Store state in global state management (Redux, Context) instead of local component state", "percentage": 85}]'::jsonb, 'React component lifecycle, state lifting', 'State persists across re-renders and conditional rendering', 'Component is unmounted and remounted when parent re-renders, losing internal state unless it''s lifted up', 0.90, 'haiku', NOW(), 'https://stackoverflow.com/questions/73371455', 'admin:1764194183'),
('useState not updating array of objects correctly', 'react', 'HIGH', '[{"solution": "Use spread operator with arrays not objects: setArray([...prevArray, newItem]) not setArray({...array})", "percentage": 94}, {"solution": "For nested updates, create new array: setArray((prev) => [...prev, ...newItems])", "percentage": 92}, {"solution": "Pass state to child components - update component prop: <Component data={array} /> not static data", "percentage": 88}]'::jsonb, 'React hooks, array operations, JavaScript spread syntax', 'Array state updates and renders correctly', 'Using object spread {} instead of array spread [], or not updating component props to use new state', 0.91, 'haiku', NOW(), 'https://stackoverflow.com/questions/63671046', 'admin:1764194183'),
('useEffect infinite loop when fetching data and updating state with wrong dependency', 'react', 'HIGH', '[{"solution": "Use correct dependency: useEffect(() => { fetchData() }, [id]) not [userInfo] - track what triggers fetch", "percentage": 95}, {"solution": "Separate concerns: fetch in one effect, dependent actions in another effect with proper dependencies", "percentage": 92}, {"solution": "Use useCallback to memoize fetch function to avoid creating new function on every render", "percentage": 87}]'::jsonb, 'React hooks, useEffect, axios or fetch API', 'Data fetches once when dependency changes, no infinite loop', 'Including state that gets updated by the effect itself in dependency array creates infinite loop', 0.93, 'haiku', NOW(), 'https://stackoverflow.com/questions/68690569', 'admin:1764194183'),
('Context API causes unnecessary re-renders of all consumers', 'react', 'HIGH', '[{"solution": "Split context: create separate contexts for different data types to minimize affected consumers", "percentage": 90}, {"solution": "Use useMemo to memoize context value: const value = useMemo(() => ({ state, setState }), [state])", "percentage": 88}, {"solution": "Consider Redux for large-scale apps where only specific selectors should trigger re-renders", "percentage": 85}]'::jsonb, 'React Context API, performance optimization', 'Only affected components re-render, performance acceptable', 'All consumers re-render when any part of context value changes, even if they only use a subset', 0.87, 'haiku', NOW(), 'https://stackoverflow.com/questions/57841048', 'admin:1764194183'),
('Redux vs Context API performance differences and use cases', 'react', 'HIGH', '[{"solution": "Use Context API for low-frequency updates (theme, auth) with few consumers", "percentage": 91}, {"solution": "Use Redux for high-frequency state changes and apps with many selectors needing specific re-renders", "percentage": 90}, {"solution": "Context is Dependency Injection, Redux is state management - use both if needed for different purposes", "percentage": 89}]'::jsonb, 'React Context, Redux, state management patterns', 'Correct tool chosen for application state management needs', 'Treating Context as full state management solution when Redux is better for complex apps', 0.89, 'haiku', NOW(), 'https://stackoverflow.com/questions/73669777', 'admin:1764194183'),
('useState not updating state synchronously after setState call', 'react', 'VERY_HIGH', '[{"solution": "Remember state updates are async: setState triggers re-render, state value updates after render completes", "percentage": 96}, {"solution": "Use useEffect hook to run code after state updates: useEffect(() => { /* use updated state */ }, [state])", "percentage": 95}, {"solution": "If you need value immediately, use a variable before setState: const newVal = value; setState(newVal)", "percentage": 92}]'::jsonb, 'React hooks, asynchronous JavaScript', 'State updates correctly after re-render, code runs in correct order', 'Calling console.log immediately after setState and expecting new value, misunderstanding async nature of updates', 0.93, 'haiku', NOW(), 'https://stackoverflow.com/questions/72637100', 'admin:1764194183'),
('Context API unnecessary re-renders of array elements in dynamic lists', 'react', 'MEDIUM', '[{"solution": "Use Redux selectors for granular control: only specific array elements trigger re-renders when they change", "percentage": 92}, {"solution": "Split context by data type: separate contexts for auth vs list vs theme", "percentage": 89}, {"solution": "Use useCallback and useMemo to stabilize context value and prevent unnecessary re-renders", "percentage": 85}]'::jsonb, 'React Context, performance profiling, React Dev Tools', 'Profiler shows only changed array elements cause re-renders', 'When array in context changes, all consumers re-render even if only one element changed', 0.86, 'haiku', NOW(), 'https://stackoverflow.com/questions/73889138', 'admin:1764194183');
