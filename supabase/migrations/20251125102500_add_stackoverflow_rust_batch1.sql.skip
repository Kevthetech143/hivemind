-- Add Stack Overflow top-voted Rust questions/answers batch 1
-- Category: stackoverflow-rust
-- Source: https://stackoverflow.com/questions/tagged/rust?tab=votes

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES
(
    'What are the differences between Rust String and str types?',
    'stackoverflow-rust',
    'VERY_HIGH',
    '[
        {"solution": "String is heap-allocated, dynamically sized, and owned. Use String when you need to own or modify strings. str is immutable UTF-8 bytes with unknown size at compile time, always appears as &str reference.", "percentage": 95, "note": "String vs &str is the most fundamental Rust concept"},
        {"solution": "String dereferences to &str. Just like Vec<T> dereferences to &[T], String dereferences to &str for borrowing.", "percentage": 90, "note": "Parallels Vec<T> and slice relationship"},
        {"solution": "String literals like \"foo\" are &''static str - embedded in executable. Use String when values change at runtime.", "percentage": 85, "note": "Static strings vs runtime strings"}
    ]'::jsonb,
    'Basic Rust knowledge, understanding of ownership',
    'Can explain difference between owned and borrowed strings, understand when to use each type',
    'Confusion between String and &str. Remember: String is Vec-like (owned, growable), &str is slice-like (borrowed view). String::from(\"literal\") creates owned copy.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str'
),
(
    'Why does println! not work in Rust unit tests?',
    'stackoverflow-rust',
    'HIGH',
    '[
        {"solution": "Rust test harness captures stdout from successful tests to keep output clean. Use cargo test -- --nocapture flag to disable capture.", "percentage": 95, "command": "cargo test -- --nocapture", "note": "Most direct solution"},
        {"solution": "Alternative: use cargo test -- --show-output for cleaner output format (Rust 1.41+)", "percentage": 85, "command": "cargo test -- --show-output"},
        {"solution": "Combine with other flags: cargo test -- --color always --nocapture for colored output", "percentage": 80, "command": "cargo test -- --color always --nocapture", "note": "For enhanced debugging"}
    ]'::jsonb,
    'Rust project with test code, cargo installed',
    'println! output appears in terminal when running tests, test passes with visible debug output',
    'Output is hidden even though test passes. Remember: test output is captured by default. Failed tests always show output. Use --nocapture for successful test output.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/25106554/why-doesnt-println-work-in-rust-unit-tests'
),
(
    'How do I concatenate strings in Rust?',
    'stackoverflow-rust',
    'VERY_HIGH',
    '[
        {"solution": "Use format! macro for any String/&str combination without consuming values: let result = format!(\"{a}{b}\");", "percentage": 95, "note": "Most flexible, modern approach"},
        {"solution": "Use push_str() with mutable String: mut_string.push_str(&borrowed_string);", "percentage": 90, "note": "Best for mutation patterns"},
        {"solution": "Use + operator but left side must be String (consumed): let result = owned_string + &borrowed_string;", "percentage": 85, "note": "Original consumed on LHS"},
        {"solution": "Use join() for arrays: [\"hello\", \"world\"].join(\" \")", "percentage": 80, "note": "Best for multiple strings with separator"}
    ]'::jsonb,
    'Basic String knowledge, Rust syntax familiarity',
    'Can concatenate multiple strings, result contains expected content, no unnecessary clones',
    'Using + operator without understanding left operand is consumed. format! creates new String and doesn''t mutate inputs. Be explicit about ownership.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings'
),
(
    'How do you disable dead code warnings at the crate level in Rust?',
    'stackoverflow-rust',
    'HIGH',
    '[
        {"solution": "Add #![allow(dead_code)] at start of crate before any code. The ! makes it crate-level (without ! applies to single item).", "percentage": 95, "command": "#![allow(dead_code)]", "note": "Most direct approach"},
        {"solution": "Suppress multiple warnings: #![allow(dead_code, unused_variables)] or #![allow(unused)]", "percentage": 90},
        {"solution": "Use Cargo.toml linting config (Rust 1.74+): [lints.rust] dead_code = \"allow\"", "percentage": 85, "note": "Modern alternative"},
        {"solution": "For individual items use #[allow(dead_code)] without ! above the struct/function", "percentage": 80}
    ]'::jsonb,
    'Rust compiler, crate file (lib.rs or main.rs)',
    'Dead code warnings no longer appear in compiler output, code compiles successfully',
    'Forgetting the ! symbol - #![allow(dead_code)] vs #[allow(dead_code)]. Crate level needs !, item level does not. Must appear before code.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/25877285/how-do-you-disable-dead-code-warnings-at-the-crate-level-in-rust'
),
(
    'How do I convert a String to an integer in Rust?',
    'stackoverflow-rust',
    'VERY_HIGH',
    '[
        {"solution": "Use parse() method with type annotation: let num: i32 = string.parse().unwrap();", "percentage": 95, "command": "let num: i32 = \"42\".parse().unwrap();", "note": "Preferred modern syntax"},
        {"solution": "Use turbofish syntax when type can''t be inferred: string.parse::<i32>().unwrap()", "percentage": 90, "command": "let num = string.parse::<i32>().unwrap();"},
        {"solution": "Use unwrap_or() for default value on parse failure: string.parse::<i32>().unwrap_or(0)", "percentage": 85},
        {"solution": "Always trim whitespace first for user input: input.trim().parse::<i32>().expect(\"valid number\")", "percentage": 90, "note": "Critical for stdin parsing"}
    ]'::jsonb,
    'String value to parse, understanding of Result type',
    'Parsing succeeds with correct integer, error handling works for invalid input, unwrap/expect/pattern matching succeeds',
    'Forgetting to handle Result type. parse() returns Result<T,E> - must unwrap, expect, or pattern match. Remember trim() for stdin input.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/27043268/convert-a-string-to-int'
),
(
    'What is the difference between iter and into_iter in Rust?',
    'stackoverflow-rust',
    'HIGH',
    '[
        {"solution": "iter() yields &T (immutable references), into_iter() yields T (owned values, consumes collection), iter_mut() yields &mut T. Use iter() for reading, into_iter() when you need ownership.", "percentage": 95, "note": "Fundamental iterator difference"},
        {"solution": "For Vec<T>: iter() borrows, into_iter() moves elements out of vector (consuming it)", "percentage": 90},
        {"solution": "Note: Arrays in Rust 1.53.0+ properly implement IntoIterator for by-value iteration (previously desugared to &array)", "percentage": 75, "note": "Historical quirk with arrays"},
        {"solution": "In for loops, for x in vec calls into_iter() automatically. Use &vec or vec.iter() to borrow instead.", "percentage": 85}
    ]'::jsonb,
    'Understanding of Vec, references, ownership model',
    'Correct iterator type used, no unexpected moves/borrows, loops iterate correctly',
    'Confusing iter() with into_iter(). iter() borrows (safe, reusable), into_iter() consumes (moves ownership). Choose based on whether you need element ownership.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter'
),
(
    'How do I print the type of a variable in Rust?',
    'stackoverflow-rust',
    'MEDIUM',
    '[
        {"solution": "Use std::any::type_name::<T>() function: fn print_type_of<T>(_: &T) { println!(\"{}\", std::any::type_name::<T>()); }", "percentage": 95, "command": "println!(\"{}\", std::any::type_name_of_val(&var));", "note": "Stable, no nightly required"},
        {"solution": "Use type_name_of_val for direct values: std::any::type_name_of_val(&var)", "percentage": 90, "command": "println!(\"{}\", std::any::type_name_of_val(&var));"},
        {"solution": "Trigger compiler error intentionally: my_var.nonexistent_method() - error message reveals type", "percentage": 75, "note": "Compile-time introspection only"},
        {"solution": "Note: type_name output format not guaranteed stable across compiler versions - use for debugging only", "percentage": 85, "note": "Important caveat"}
    ]'::jsonb,
    'Variable to inspect, Rust std library',
    'Type name printed to stdout/error, compiler error shows inferred type',
    'Using nightly-only features when stable std::any::type_name works fine. Remember: this is debug-only, output format not guaranteed. Use for troubleshooting.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/21747136/how-do-i-print-the-type-of-a-variable-in-rust'
),
(
    'Why can''t I store a value and a reference to that value in the same struct?',
    'stackoverflow-rust',
    'MEDIUM',
    '[
        {"solution": "Fundamental memory safety issue: when struct moves, owned value''s memory address changes but reference still points to old (now invalid) address. Rust prevents this to avoid dangling pointers.", "percentage": 95, "note": "Root cause explanation"},
        {"solution": "Recommended solution: restructure design - don''t store both owned value and reference together. Use methods to provide references when needed.", "percentage": 90},
        {"solution": "Alternative: use libraries enabling self-referential structs: ouroboros, self_cell, or yoke crates which prevent moves via heap allocation", "percentage": 80, "note": "Crate-based workaround"},
        {"solution": "Use reference counting: Arc or Arc<Mutex<T>> for shared ownership when appropriate", "percentage": 75}
    ]'::jsonb,
    'Struct definition attempt, understanding of lifetimes and references',
    'Code compiles or error message understood, design refactored to avoid self-references',
    'Trying to force self-referential structs. Remember: lifetimes track memory addresses, not just existence. Moving invalidates references. Restructure to avoid pattern.',
    0.85,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct'
),
(
    'How do I match a String against string literals in Rust?',
    'stackoverflow-rust',
    'HIGH',
    '[
        {"solution": "Use .as_str() to convert String to &str for pattern matching: match stringvar.as_str() { \"a\" => ..., _ => ... }", "percentage": 95, "command": "match stringvar.as_str() { \"a\" => println!(\"0\"), _ => println!(\"other\") }", "note": "Most concise, recommended"},
        {"solution": "Alternative: use &stringvar[..] slice syntax: match &stringvar[..] { \"a\" => ..., _ => ... }", "percentage": 85},
        {"solution": "Use dereferencing: match &*stringvar { \"a\" => ..., _ => ... }", "percentage": 80},
        {"solution": "For stdin input, always use .trim() first to remove newline: match input.trim() { \"a\" => ..., _ => ... }", "percentage": 90, "note": "Critical for user input"}
    ]'::jsonb,
    'String variable, string literals to match against',
    'Pattern matching works, correct branches execute for literal strings',
    'Type mismatch between String and &str string literals. Remember: String is heap-allocated, string literals are &str. Use .as_str() or .trim() for pattern matching.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/25383488/how-to-match-a-string-against-string-literals'
),
(
    'How do I create a Rust package with both a library and a binary?',
    'stackoverflow-rust',
    'MEDIUM',
    '[
        {"solution": "Create both src/lib.rs and src/main.rs. No Cargo.toml changes needed. main.rs automatically becomes executable and can use library via: use package_name::function_name;", "percentage": 95, "note": "Simplest approach"},
        {"solution": "For multiple binaries, place additional sources in src/bin/ directory. Each file compiles to separate executable. Run with: cargo run --bin binary_name", "percentage": 90},
        {"solution": "For large projects, use workspace: create subdirectory with library, main binary depends on it as path dependency", "percentage": 85, "note": "Best for separation of concerns"},
        {"solution": "Workspace benefit: binary-specific dependencies don''t affect library users, avoids redundant builds", "percentage": 80}
    ]'::jsonb,
    'Rust project, Cargo initialized',
    'cargo build compiles both library and binary, cargo test runs tests, cargo run --bin works for multiple binaries',
    'Forgetting that main.rs and lib.rs coexist automatically. No special Cargo.toml configuration needed for simple library + binary layout.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/26946646/package-with-both-a-library-and-a-binary'
),
(
    'Why does the Rust compiler not optimize code with mutable reference aliasing assumptions?',
    'stackoverflow-rust',
    'LOW',
    '[
        {"solution": "Rust originally enabled LLVM''s noalias attribute for mutable references (like C''s restrict keyword) but this caused miscompiled code. Optimization was disabled/re-enabled multiple times as LLVM bugs were discovered.", "percentage": 85, "note": "Historical context"},
        {"solution": "The problem: applying noalias everywhere (far more prevalent than C) exposed LLVM optimizer corner cases. Loop unrolling and aliasing metadata interaction caused incorrect code generation.", "percentage": 85},
        {"solution": "Current status (Rust 1.54+): noalias conditionally enabled based on LLVM version (LLVM 12+). Can manually test with -Zmutable-noalias=yes flag", "percentage": 80, "command": "rustc -Z mutable-noalias=yes"},
        {"solution": "Takeaway: compiler writers balance aggressive optimizations against real-world optimizer bugs. Conservative approach ensures correctness over performance.", "percentage": 75}
    ]'::jsonb,
    'Understanding of compiler optimization, LLVM knowledge helpful',
    'Compilation succeeds, code runs correctly, optimization behavior matches expectations',
    'Assuming mutable references can always be optimized with aliasing assumptions. Reality: LLVM optimizations complex, safety over speed. noalias attribute conditionally applied.',
    0.80,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/57259126/why-does-the-rust-compiler-not-optimize-code-assuming-that-two-mutable-references-cannot-alias'
),
(
    'What is the syntax for a multiline string literal in Rust?',
    'stackoverflow-rust',
    'MEDIUM',
    '[
        {"solution": "Direct multiline: let s = \"line one\\nline two\"; or include literal newlines: let s = \"line one\\nline two\";", "percentage": 95, "note": "Simplest approach"},
        {"solution": "Escaped newlines to break in code without adding them: let s = \"one line \\\\\\n    written over \\\\\\n    several\"; produces \"one line written over several\"", "percentage": 85},
        {"solution": "Raw string literals for code/quotes: let shader = r#\"\\n    #version 330\\n    void main() { }\\n\"#;", "percentage": 90, "note": "Best for embedded code"},
        {"solution": "Multiple hash delimiters for strings containing hashes: r###\"string with # and \"quotes\"\"###", "percentage": 80}
    ]'::jsonb,
    'Need for multiline string in Rust program',
    'String literal compiles, contains expected content and newlines, embedded code renders correctly',
    'Using escape sequences when raw strings are cleaner. Raw strings (r#\"...\"#) better for code/URLs. Regular strings allow literal newlines inside quotes.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/29483365/what-is-the-syntax-for-a-multiline-string-literal'
);
