-- Add Postgres functions required by clauderepo Edge Functions
-- These enable search, rate limiting, and ticketing system

-- Drop existing functions to allow structure changes
DROP FUNCTION IF EXISTS search_knowledge(text, integer);
DROP FUNCTION IF EXISTS check_rate_limit(text, text, integer, integer);
DROP FUNCTION IF EXISTS start_troubleshooting_ticket(text, text);

-- Search function with full-text search and ranking
CREATE OR REPLACE FUNCTION search_knowledge(
    search_query TEXT,
    result_limit INTEGER DEFAULT 5
)
RETURNS TABLE (
    id BIGINT,
    query TEXT,
    category TEXT,
    hit_frequency TEXT,
    solutions JSONB,
    common_pitfalls TEXT,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ,
    view_count INTEGER,
    command_copy_count INTEGER,
    repeat_search_rate REAL,
    success_rate REAL,
    search_rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        ke.id,
        ke.query,
        ke.category,
        ke.hit_frequency,
        ke.solutions,
        ke.common_pitfalls,
        ke.created_at,
        ke.updated_at,
        ke.view_count,
        ke.command_copy_count,
        ke.repeat_search_rate,
        ke.success_rate,
        ts_rank(
            to_tsvector('english', ke.query || ' ' || COALESCE(ke.common_pitfalls, '') || ' ' || ke.category),
            plainto_tsquery('english', search_query)
        ) as search_rank
    FROM knowledge_entries ke
    WHERE to_tsvector('english', ke.query || ' ' || COALESCE(ke.common_pitfalls, '') || ' ' || ke.category)
          @@ plainto_tsquery('english', search_query)
    ORDER BY
        search_rank DESC,
        ke.success_rate DESC NULLS LAST,
        ke.view_count DESC
    LIMIT result_limit;
END;
$$ LANGUAGE plpgsql;

-- Rate limiting check function (window-based)
CREATE OR REPLACE FUNCTION check_rate_limit(
    p_ip_address TEXT,
    p_endpoint TEXT,
    p_limit INTEGER,
    p_window_minutes INTEGER DEFAULT 60
) RETURNS BOOLEAN AS $$
DECLARE
    v_count INTEGER;
    v_window_start TIMESTAMPTZ;
BEGIN
    -- Get current count and window start
    SELECT request_count, window_start
    INTO v_count, v_window_start
    FROM rate_limits
    WHERE ip_address = p_ip_address AND endpoint = p_endpoint;

    -- If no record or window expired, reset
    IF v_count IS NULL OR (NOW() - v_window_start) > (p_window_minutes || ' minutes')::INTERVAL THEN
        INSERT INTO rate_limits (ip_address, endpoint, request_count, window_start)
        VALUES (p_ip_address, p_endpoint, 1, NOW())
        ON CONFLICT (ip_address, endpoint)
        DO UPDATE SET request_count = 1, window_start = NOW();
        RETURN TRUE;
    END IF;

    -- If under limit, increment
    IF v_count < p_limit THEN
        UPDATE rate_limits
        SET request_count = request_count + 1
        WHERE ip_address = p_ip_address AND endpoint = p_endpoint;
        RETURN TRUE;
    END IF;

    -- Over limit
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- Start troubleshooting ticket function
CREATE OR REPLACE FUNCTION start_troubleshooting_ticket(
    p_problem TEXT,
    p_category TEXT
)
RETURNS TABLE (
    ticket_id TEXT,
    category TEXT,
    checklist JSONB
) AS $$
DECLARE
    v_ticket_id TEXT;
    v_checklist JSONB;
BEGIN
    -- Generate ticket ID
    v_ticket_id := 'TICKET_' || TO_CHAR(NOW(), 'YYYYMMDD') || '_' || LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0');

    -- Generate category-specific checklist
    v_checklist := CASE p_category
        WHEN 'mcp-troubleshooting' THEN
            '[{"step": "Verify MCP server is installed", "status": "pending"},
              {"step": "Check MCP config file syntax", "status": "pending"},
              {"step": "Test with minimal config", "status": "pending"}]'::jsonb
        WHEN 'web-automation' THEN
            '[{"step": "Check selector exists on page", "status": "pending"},
              {"step": "Wait for element to be visible", "status": "pending"},
              {"step": "Verify no JavaScript errors", "status": "pending"}]'::jsonb
        ELSE
            '[{"step": "Reproduce the issue", "status": "pending"},
              {"step": "Check recent changes", "status": "pending"},
              {"step": "Review logs/errors", "status": "pending"}]'::jsonb
    END;

    -- Insert ticket (table is called troubleshooting_sessions, not troubleshooting_tickets)
    INSERT INTO troubleshooting_sessions (ticket_id, problem, category, status, steps_tried)
    VALUES (v_ticket_id, p_problem, p_category, 'open', v_checklist);

    RETURN QUERY
    SELECT v_ticket_id, p_category, v_checklist;
END;
$$ LANGUAGE plpgsql;

-- Increment command copy count
CREATE OR REPLACE FUNCTION increment_command_copy(solution_query_text TEXT)
RETURNS VOID AS $$
BEGIN
    UPDATE knowledge_entries
    SET command_copy_count = command_copy_count + 1
    WHERE query = solution_query_text;
END;
$$ LANGUAGE plpgsql;

-- Update timestamp trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to knowledge_entries
DROP TRIGGER IF EXISTS update_knowledge_entries_updated_at ON knowledge_entries;
CREATE TRIGGER update_knowledge_entries_updated_at
BEFORE UPDATE ON knowledge_entries
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
