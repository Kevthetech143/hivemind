-- Add ASP.NET Core common errors and solutions - Batch 1
-- Source: https://learn.microsoft.com/en-us/aspnet/core/
-- Extracted: 2025-11-25

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES
(
    'ASP.NET Core: Response already started exception - cannot modify headers after response has begun',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Check HasStarted property before writing to response: if (!HttpContext.Response.HasStarted) { /* modify headers */ }", "percentage": 95, "note": "Official recommended approach to prevent protocol violations"},
        {"solution": "Ensure terminal middleware (Run delegates) do not call next.Invoke()", "percentage": 92, "note": "Terminal middleware should not invoke the next middleware"},
        {"solution": "Perform all response modifications before calling next() in middleware", "percentage": 90, "note": "Response body writes must complete before next() is invoked"},
        {"solution": "Use middleware that reads entire request body before calling next if body rewind is needed", "percentage": 85, "command": "Use EnableBuffering() on request stream"}
    ]'::jsonb,
    'ASP.NET Core application with middleware pipeline configured, HttpContext accessible',
    'Response writes succeed without throwing InvalidOperationException, Headers set correctly before body writing',
    'Do not attempt to modify response after HasStarted returns true. Do not call next.Invoke in terminal middleware. Always check response state before writing.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware'
),
(
    'ASP.NET Core: Incorrect middleware ordering causing security and functionality issues',
    'aspnet-core',
    'VERY_HIGH',
    '[
        {"solution": "Place UseAuthentication before UseAuthorization in middleware pipeline", "percentage": 95, "note": "Authentication must run before authorization checks"},
        {"solution": "Position UseCors before UseResponseCaching middleware", "percentage": 92, "note": "CORS must process before response caching"},
        {"solution": "Register exception handlers early: app.UseExceptionHandler() near beginning of pipeline", "percentage": 93, "note": "Exception handlers must wrap downstream middleware"},
        {"solution": "Place UseRequestLocalization before culture-sensitive middleware", "percentage": 90, "note": "Culture detection must occur before services use current culture"}
    ]'::jsonb,
    'ASP.NET Core application with multiple middleware components, Program.cs configured',
    'Authentication succeeds, authorization checks apply correctly, CORS headers present in responses, exceptions handled properly',
    'Middleware order is critical - swapping authentication and authorization causes 403 errors. CORS after caching causes missing headers. Exception handlers must be first.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware'
),
(
    'ASP.NET Core: Ambiguous route match exception - multiple routes matching same URL with equal priority',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Make one route template more specific: /Products/List is more specific than /Products/{id}", "percentage": 93, "note": "Specificity resolves ambiguity without affecting other routes"},
        {"solution": "Use Order property on routes to disambiguate: [Route(\"/api/users\", Order = 1)]", "percentage": 90, "note": "Lower order values execute first"},
        {"solution": "Add route constraints to differentiate matches: {id:int} vs {id:guid}", "percentage": 92, "note": "Constraints narrow which requests match each route"},
        {"solution": "Verify endpoint registration order - more specific routes should register first", "percentage": 88, "note": "Registration order matters when constraints don''t fully disambiguate"}
    ]'::jsonb,
    'ASP.NET Core routing configured, multiple routes defined, endpoint mapping in place',
    'Single route matches each request, AmbiguousMatchException no longer thrown, correct endpoint executes',
    'Do not rely solely on Order property - make routes specific instead. Generic catch-all routes should register last. Double-check route templates for unintended overlaps.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing'
),
(
    'ASP.NET Core: InvalidOperationException - No authenticationScheme specified, no DefaultAuthenticateScheme found',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Call AddAuthentication with default scheme: builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)", "percentage": 95, "note": "Required when multiple schemes are registered"},
        {"solution": "Use AddAuthentication with configuration action to set defaults: AddAuthentication(options => options.DefaultScheme = ...)", "percentage": 93, "note": "Configure default scheme in lambda expression"},
        {"solution": "Register at least one authentication handler before using authentication", "percentage": 90, "note": "AddJwtBearer, AddCookie, or other scheme must follow AddAuthentication"},
        {"solution": "Call UseAuthentication middleware in correct pipeline position before UseAuthorization", "percentage": 88, "note": "Middleware presence depends on scheme registration"}
    ]'::jsonb,
    'ASP.NET Core application with multiple authentication schemes configured, Program.cs modified',
    'Authentication initializes without exception, requests authenticate successfully against specified scheme',
    'Multiple schemes require explicit default. Missing AddAuthentication call causes this error. Scheme handlers must be added after AddAuthentication.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/security/authentication'
),
(
    'ASP.NET Core: Scoped service in middleware constructor causes runtime scope validation error',
    'aspnet-core',
    'MEDIUM',
    '[
        {"solution": "Inject scoped service into Invoke/InvokeAsync method instead of constructor", "percentage": 95, "note": "Scoped services must be resolved per-request, not at middleware construction"},
        {"solution": "Use factory-based middleware activation with IMiddlewareFactory", "percentage": 90, "note": "Factory pattern allows scoped service injection per request"},
        {"solution": "Convert scoped dependency to singleton if truly shared across requests", "percentage": 85, "note": "Only if the service is stateless and thread-safe"},
        {"solution": "Use service locator pattern as temporary workaround: context.RequestServices.GetService<T>()", "percentage": 75, "note": "Last resort - still not ideal for dependency injection"}
    ]'::jsonb,
    'Custom middleware class implemented, scoped services registered, DI container configured',
    'Middleware initializes without scope validation error, scoped services resolve at request time, middleware processes correctly',
    'Never inject scoped services via middleware constructor. Constructor runs once, but scoped services need per-request scope. This violates DI rules.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection'
),
(
    'ASP.NET Core: HttpClientHandler socket exhaustion and DNS staleness from creating new HttpClient instances',
    'aspnet-core',
    'VERY_HIGH',
    '[
        {"solution": "Use IHttpClientFactory to manage HttpClient pooling: var client = _httpClientFactory.CreateClient()", "percentage": 95, "note": "Official Microsoft pattern prevents socket exhaustion"},
        {"solution": "Register factory in DI: builder.Services.AddHttpClient() or AddHttpClient(named)", "percentage": 94, "note": "Factory must be registered before use"},
        {"solution": "Never manually create new HttpClient() instances in loops or per-request", "percentage": 95, "note": "Leads to thousands of sockets being held"},
        {"solution": "Configure named clients with base addresses and default headers", "percentage": 90, "command": "builder.Services.AddHttpClient(\"MyClient\").ConfigureHttpClient(c => c.BaseAddress = ...)"}
    ]'::jsonb,
    'ASP.NET Core application with external API calls, DI container configured, IHttpClientFactory registered',
    'No socket exhaustion errors, DNS resolution refreshes automatically, HTTP requests complete successfully',
    'Creating new HttpClient instances causes socket leaks and DNS issues. Always use IHttpClientFactory. Pool management is automatic with factory.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests'
),
(
    'ASP.NET Core: Multiple parameters bound from request body throws exception',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Refactor action to accept single wrapper object containing all body parameters", "percentage": 96, "note": "Only one parameter can bind from request body per action"},
        {"solution": "Create data transfer object (DTO) class combining multiple parameters", "percentage": 95, "note": "Wrap multiple inputs into single class"},
        {"solution": "Use different binding sources for additional parameters: [FromQuery], [FromRoute], [FromHeader]", "percentage": 92, "note": "Only body binding is limited to single parameter"},
        {"solution": "Split into multiple action methods if logic truly requires distinct endpoints", "percentage": 85, "note": "Each endpoint can have one body parameter"}
    ]'::jsonb,
    'ASP.NET Core Web API controller created, model classes defined, action method implemented',
    'Action accepts single object from request body, model binding succeeds, no exception thrown, data deserializes correctly',
    'Multiple [FromBody] attributes in single action throw exception. The framework allows only one body parameter. Use wrapper objects instead.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/web-api'
),
(
    'ASP.NET Core: Configuration binding fails - options class missing public parameterless constructor',
    'aspnet-core',
    'MEDIUM',
    '[
        {"solution": "Add public parameterless constructor to options class: public class AppOptions { public AppOptions() { } }", "percentage": 97, "note": "ConfigurationBinder requires parameterless constructor"},
        {"solution": "Ensure all properties are public read-write, not fields: public string Key { get; set; }", "percentage": 96, "note": "Fields are not bound by ConfigurationBinder"},
        {"solution": "Use options pattern: services.Configure<AppOptions>(config.GetSection(\"App\"))", "percentage": 94, "note": "Proper way to bind configuration to classes"},
        {"solution": "Verify configuration section exists and is accessible before binding", "percentage": 88, "note": "Null section returns default values without error"}
    ]'::jsonb,
    'ASP.NET Core application, configuration file (appsettings.json) present, options class defined, DI configured',
    'Configuration binds to class properties successfully, IOptions<T> injection returns populated object, no binding exceptions',
    'Options classes must have parameterless constructors. Only public properties bind, not fields. Configuration paths are case-insensitive.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration'
),
(
    'ASP.NET Core: Environment variable hierarchy not working - colon separator fails on some platforms',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Use double underscores (__) instead of colons (:) for hierarchical keys in environment variables", "percentage": 96, "note": "Colons fail on non-Windows platforms, underscores work everywhere"},
        {"solution": "Set ASPNETCORE_Database__ConnectionString instead of ASPNETCORE_Database:ConnectionString", "percentage": 95, "note": "Underscores are automatically converted to colons"},
        {"solution": "Restart application after setting environment variables for changes to take effect", "percentage": 92, "note": "Environment variables read at startup, not monitored for changes"},
        {"solution": "Verify prefix matches configuration provider: ASPNETCORE_, DOTNET_, or custom prefix", "percentage": 88, "note": "Wrong prefix means variable is ignored"}
    ]'::jsonb,
    'ASP.NET Core application, environment variables set in system/container, configuration providers initialized',
    'Environment variables override appsettings.json values, hierarchy nesting works correctly, configuration loads without errors',
    'Colons don''t work reliably across platforms - always use double underscores. Variables must be set before app starts. Case sensitivity varies by platform.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration'
),
(
    'ASP.NET Core: Static files middleware provides no authorization checks - publicly accessible',
    'aspnet-core',
    'HIGH',
    '[
        {"solution": "Implement custom middleware to check authorization before serving files", "percentage": 93, "note": "Static files middleware has no built-in authorization"},
        {"solution": "Move protected files outside wwwroot directory and serve via authorization-checked endpoint", "percentage": 94, "note": "Only files in wwwroot are served by static middleware"},
        {"solution": "Use ASP.NET Core authorization attributes on controller action returning file", "percentage": 92, "note": "FileResult respects controller-level authorization"},
        {"solution": "Restrict file access at IIS level if behind reverse proxy", "percentage": 88, "note": "Additional layer of protection outside application"}
    ]'::jsonb,
    'ASP.NET Core application with static files, wwwroot folder configured, authorization system implemented',
    'Protected files not accessible without authentication, static assets load successfully for authorized users, public files remain accessible',
    'UseStaticFiles provides zero authorization - any file in wwwroot is public. Never store secrets or user data in wwwroot. Use controller endpoints for protected downloads.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware'
),
(
    'ASP.NET Core: Logging level configuration override issues - provider-specific settings override global settings',
    'aspnet-core',
    'MEDIUM',
    '[
        {"solution": "Understand hierarchy: Logging.{PROVIDER}.LogLevel overrides Logging.LogLevel globally", "percentage": 95, "note": "Provider-specific configuration takes precedence"},
        {"solution": "Set log level in appsettings.json under correct provider key: \"Logging\": { \"Console\": { \"LogLevel\": {} } }", "percentage": 93, "note": "Provider name must match registered provider type"},
        {"solution": "Use environment variables with double underscores: Logging__Console__LogLevel__Default=Warning", "percentage": 92, "note": "Hierarchical configuration via environment variables"},
        {"solution": "Configure EventLog provider explicitly as it doesn''t inherit default settings", "percentage": 90, "note": "EventLog defaults to Warning, other providers inherit"}
    ]'::jsonb,
    'ASP.NET Core application with logging configured, appsettings.json present, multiple log providers registered',
    'Log levels apply correctly, debug messages appear in development, production logs show appropriate levels, no unexpected log suppression',
    'Provider-specific settings override global settings. EventLog provider ignores defaults. Scope inclusion must be explicitly enabled per provider.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging'
);
