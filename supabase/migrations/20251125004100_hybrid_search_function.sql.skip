-- Phase 2: Hybrid Search Function (FTS + Vector Similarity)
-- Combines keyword matching with semantic understanding

DROP FUNCTION IF EXISTS search_knowledge(text, integer);
DROP FUNCTION IF EXISTS search_knowledge_semantic(vector, integer);

-- Main hybrid search function
CREATE OR REPLACE FUNCTION search_knowledge(
    search_query TEXT,
    result_limit INTEGER DEFAULT 5,
    search_embedding vector(1536) DEFAULT NULL
)
RETURNS TABLE (
    id BIGINT,
    query TEXT,
    category TEXT,
    hit_frequency TEXT,
    solutions JSONB,
    common_pitfalls TEXT,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ,
    view_count INTEGER,
    command_copy_count INTEGER,
    repeat_search_rate REAL,
    success_rate REAL,
    search_rank REAL
) AS $$
BEGIN
    -- If embedding provided, use hybrid search (FTS + vector similarity)
    IF search_embedding IS NOT NULL THEN
        RETURN QUERY
        SELECT
            ke.id,
            ke.query,
            ke.category,
            ke.hit_frequency,
            ke.solutions,
            ke.common_pitfalls,
            ke.created_at,
            ke.updated_at,
            ke.view_count,
            ke.command_copy_count,
            ke.repeat_search_rate,
            ke.success_rate,
            -- Hybrid ranking: 50% semantic similarity + 30% FTS + 20% success rate
            (
                (1 - (ke.embedding <=> search_embedding)) * 0.5 +
                COALESCE(
                    ts_rank_cd(
                        setweight(to_tsvector('english', ke.query), 'A') ||
                        setweight(to_tsvector('english', COALESCE(ke.common_pitfalls, '')), 'B') ||
                        setweight(to_tsvector('english', ke.category), 'C'),
                        plainto_tsquery('english', search_query)
                    ) * 0.3,
                    0
                ) +
                COALESCE(ke.success_rate, 0.5) * 0.2
            )::REAL as search_rank
        FROM knowledge_entries ke
        WHERE ke.embedding IS NOT NULL
        ORDER BY search_rank DESC
        LIMIT result_limit;

        RETURN;
    END IF;

    -- Otherwise, use Phase 1 FTS + trigram fallback
    -- First try: Weighted full-text search
    RETURN QUERY
    SELECT
        ke.id,
        ke.query,
        ke.category,
        ke.hit_frequency,
        ke.solutions,
        ke.common_pitfalls,
        ke.created_at,
        ke.updated_at,
        ke.view_count,
        ke.command_copy_count,
        ke.repeat_search_rate,
        ke.success_rate,
        ts_rank_cd(
            setweight(to_tsvector('english', ke.query), 'A') ||
            setweight(to_tsvector('english', COALESCE(ke.common_pitfalls, '')), 'B') ||
            setweight(to_tsvector('english', ke.category), 'C'),
            plainto_tsquery('english', search_query)
        ) as search_rank
    FROM knowledge_entries ke
    WHERE
        setweight(to_tsvector('english', ke.query), 'A') ||
        setweight(to_tsvector('english', COALESCE(ke.common_pitfalls, '')), 'B') ||
        setweight(to_tsvector('english', ke.category), 'C')
        @@ plainto_tsquery('english', search_query)
    ORDER BY
        search_rank DESC,
        ke.success_rate DESC NULLS LAST,
        ke.view_count DESC
    LIMIT result_limit;

    IF FOUND THEN
        RETURN;
    END IF;

    -- Fallback: Trigram similarity search for fuzzy/typo matching
    RETURN QUERY
    SELECT
        ke.id,
        ke.query,
        ke.category,
        ke.hit_frequency,
        ke.solutions,
        ke.common_pitfalls,
        ke.created_at,
        ke.updated_at,
        ke.view_count,
        ke.command_copy_count,
        ke.repeat_search_rate,
        ke.success_rate,
        (
            similarity(ke.query, search_query) * 0.6 +
            similarity(ke.category, search_query) * 0.2 +
            similarity(COALESCE(ke.common_pitfalls, ''), search_query) * 0.2
        )::REAL as search_rank
    FROM knowledge_entries ke
    WHERE
        ke.query % search_query OR
        ke.category % search_query OR
        COALESCE(ke.common_pitfalls, '') % search_query
    ORDER BY
        search_rank DESC,
        ke.success_rate DESC NULLS LAST,
        ke.view_count DESC
    LIMIT result_limit;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION search_knowledge IS
'Hybrid search supporting both keyword-based FTS and semantic vector search.
When embedding provided: 50% semantic + 30% FTS + 20% success rate
When no embedding: Phase 1 weighted FTS with trigram fallback';
