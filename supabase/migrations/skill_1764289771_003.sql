INSERT INTO knowledge_entries (query, category, type, solutions, executable_type, prerequisites, common_pitfalls, success_indicators, preview_summary, source_url, contributor_email)
VALUES (
  'Node.js Backend Patterns - Build production-ready Node.js backend services with Express/Fastify, implementing middleware patterns, error handling, authentication, database integration, and API design',
  'claude-code',
  'skill',
  '[{"solution": "Express.js Setup with Security Middleware", "cli": {"macos": "npm init -y && npm install express helmet cors compression && node -e \"const express = require(''express''); const app = express(); app.use(require(''helmet'')()); app.use(require(''cors'')()); app.listen(3000)\"", "linux": "npm init -y && npm install express helmet cors compression && node -e \"const express = require(''express''); const app = express(); app.use(require(''helmet'')()); app.use(require(''cors'')()); app.listen(3000)\"", "windows": "npm init -y && npm install express helmet cors compression && node -e \"const express = require(''express''); const app = express(); app.use(require(''helmet'')()); app.use(require(''cors'')()); app.listen(3000)\"" }, "manual": "Initialize Node.js project with npm. Install Express and security middleware: helmet for headers, cors for cross-origin requests, compression for gzip. Set up basic server with middleware chain. Use process.env.PORT for configuration.", "note": "Always use helmet middleware to set HTTP headers securely" }, {"solution": "Layered Architecture with Dependency Injection", "cli": {"macos": "mkdir -p src/{controllers,services,repositories,middleware,routes,types} && npm install pg bcrypt jsonwebtoken express", "linux": "mkdir -p src/{controllers,services,repositories,middleware,routes,types} && npm install pg bcrypt jsonwebtoken express", "windows": "mkdir -p src/{controllers,services,repositories,middleware,routes,types} && npm install pg bcrypt jsonwebtoken express" }, "manual": "Create directory structure: controllers handle HTTP, services contain business logic, repositories access data. Controllers call services, services call repositories. Create DI container to resolve dependencies. Inject repository into service, service into controller. This separation makes testing and maintenance easier.", "note": "Dependency injection enables loose coupling and easier unit testing" }, {"solution": "Authentication with JWT and Bcrypt", "cli": {"macos": "npm install jsonwebtoken bcrypt dotenv && node -e \"const jwt = require(''jsonwebtoken''); const token = jwt.sign({userId: ''123''}, ''secret'', {expiresIn: ''15m''}); console.log(token)\"", "linux": "npm install jsonwebtoken bcrypt dotenv && node -e \"const jwt = require(''jsonwebtoken''); const token = jwt.sign({userId: ''123''}, ''secret'', {expiresIn: ''15m''}); console.log(token)\"", "windows": "npm install jsonwebtoken bcrypt dotenv && node -e \"const jwt = require(''jsonwebtoken''); const token = jwt.sign({userId: ''123''}, ''secret'', {expiresIn: ''15m''}); console.log(token)\"" }, "manual": "Hash passwords using bcrypt with salt rounds 10. Generate JWT tokens with userId and email in payload. Set short expiration (15m) for access tokens. Use refresh tokens (7d) for longer-lived credentials. Validate token in authentication middleware before route handlers.", "note": "Never store plaintext passwords. Always use bcrypt with proper salt rounds" }, {"solution": "Database Connection Pool and Transactions", "cli": {"macos": "npm install pg && node -e \"const {Pool} = require(''pg''); const pool = new Pool({max: 20}); pool.query(''SELECT NOW()'').then(res => console.log(res.rows))\"", "linux": "npm install pg && node -e \"const {Pool} = require(''pg''); const pool = new Pool({max: 20}); pool.query(''SELECT NOW()'').then(res => console.log(res.rows))\"", "windows": "npm install pg && node -e \"const {Pool} = require(''pg''); const pool = new Pool({max: 20}); pool.query(''SELECT NOW()'').then(res => console.log(res.rows))\"" }, "manual": "Configure PostgreSQL connection pool with max connections (20), idle timeout (30s), connection timeout (2s). Use pool.connect() for transactions. Call BEGIN before operations, COMMIT on success, ROLLBACK on error. Always release connection in finally block to return to pool.", "note": "Connection pooling prevents exhausting database connections" }, {"solution": "Input Validation with Zod Middleware", "cli": {"macos": "npm install zod && npm install express && cat > validate.js <<''EOF''\nconst {z} = require(''zod'');\nconst schema = z.object({body: z.object({email: z.string().email()})});\nEOF", "linux": "npm install zod && npm install express && cat > validate.js <<''EOF''\nconst {z} = require(''zod'');\nconst schema = z.object({body: z.object({email: z.string().email()})});\nEOF", "windows": "npm install zod && npm install express && cat > validate.js <<''EOF''\nconst {z} = require(''zod'');\nconst schema = z.object({body: z.object({email: z.string().email()})});\nEOF" }, "manual": "Use Zod schemas to validate request body, query, and params. Create validation middleware that catches ZodError and passes errors to error handler. Validate at API boundary before passing to service layer. Return 400 status with detailed error messages on validation failure.", "note": "Validation middleware catches errors early before business logic executes" }, {"solution": "Global Error Handler with Custom Error Classes", "cli": {"macos": "npm install express && cat > errors.js <<''EOF''\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\nEOF", "linux": "npm install express && cat > errors.js <<''EOF''\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\nEOF", "windows": "npm install express && cat > errors.js <<''EOF''\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\nEOF" }, "manual": "Create AppError base class with message and statusCode. Extend with specific errors: ValidationError (400), NotFoundError (404), UnauthorizedError (401). Register error handler middleware last in chain with 4 parameters (err, req, res, next). Log unexpected errors, hide details in production.", "note": "Error handler middleware must be registered after all other middleware" }, {"solution": "Rate Limiting with Redis", "cli": {"macos": "npm install express-rate-limit rate-limit-redis ioredis && node -e \"const redis = require(''ioredis''); const r = new redis(); r.set(''test'', ''value'')\"", "linux": "npm install express-rate-limit rate-limit-redis ioredis && node -e \"const redis = require(''ioredis''); const r = new redis(); r.set(''test'', ''value'')\"", "windows": "npm install express-rate-limit rate-limit-redis ioredis && node -e \"const redis = require(''ioredis''); const r = new redis(); r.set(''test'', ''value'')\"" }, "manual": "Create separate limiters for general API (100 req/15min) and auth endpoints (5 req/15min). Use Redis store for distributed rate limiting across servers. Configure with windowMs, max, and message. Apply apiLimiter to all routes, authLimiter to login/register.", "note": "Redis-backed rate limiting prevents brute force attacks on auth endpoints" }, {"solution": "Structured Logging with Pino", "cli": {"macos": "npm install pino pino-pretty && node -e \"const pino = require(''pino''); const logger = pino(); logger.info({msg: ''Request'', method: ''GET'', duration: 25})\"", "linux": "npm install pino pino-pretty && node -e \"const pino = require(''pino''); const logger = pino(); logger.info({msg: ''Request'', method: ''GET'', duration: 25})\"", "windows": "npm install pino pino-pretty && node -e \"const pino = require(''pino''); const logger = pino(); logger.info({msg: ''Request'', method: ''GET'', duration: 25})\"" }, "manual": "Configure pino with appropriate log level from NODE_ENV. Use structured logging (JSON) with key-value pairs. Log HTTP method, URL, status, duration, user IP, error stack traces. Use different levels: info (requests), warn (slow), error (failures). Integrate with monitoring/alerting.", "note": "Structured logging enables searching and filtering across log aggregators" }, {"solution": "Caching with Redis Decorator", "cli": {"macos": "npm install ioredis && cat > cache.js <<''EOF''\nconst redis = new (require(''ioredis''))();\nconst cache = async (key) => {\n  const cached = await redis.get(key);\n  return cached ? JSON.parse(cached) : null;\n};\nEOF", "linux": "npm install ioredis && cat > cache.js <<''EOF''\nconst redis = new (require(''ioredis''))();\nconst cache = async (key) => {\n  const cached = await redis.get(key);\n  return cached ? JSON.parse(cached) : null;\n};\nEOF", "windows": "npm install ioredis && cat > cache.js <<''EOF''\nconst redis = new (require(''ioredis''))();\nconst cache = async (key) => {\n  const cached = await redis.get(key);\n  return cached ? JSON.parse(cached) : null;\n};\nEOF" }, "manual": "Create CacheService with get/set/delete methods. Use Redis SETEX for TTL. Create @Cacheable decorator for automatic caching of service methods. On cache miss, call original method and cache result. Invalidate pattern on data mutations. TTL typically 300-3600 seconds.", "note": "@Cacheable decorator pattern reduces database queries for frequently accessed data" }, {"solution": "REST API Response Wrapper", "cli": {"macos": "cat > response.js <<''EOF''\nconst success = (res, data, msg) => res.json({status: ''success'', data, message: msg});\nconst error = (res, msg, code) => res.status(code).json({status: ''error'', message: msg});\nEOF", "linux": "cat > response.js <<''EOF''\nconst success = (res, data, msg) => res.json({status: ''success'', data, message: msg});\nconst error = (res, msg, code) => res.status(code).json({status: ''error'', message: msg});\nEOF", "windows": "cat > response.js <<''EOF''\nconst success = (res, data, msg) => res.json({status: ''success'', data, message: msg});\nconst error = (res, msg, code) => res.status(code).json({status: ''error'', message: msg});\nEOF" }, "manual": "Standardize all API responses with status field (''success''/''error''). Include data for successful responses. Include pagination object for list endpoints with page, limit, total, pages. Use consistent error format with message and optional errors array for validation.", "note": "Consistent response format makes client integration easier and cleaner" }]'::jsonb,
  'script',
  'Node.js 16+ installed. npm or yarn package manager. TypeScript optional but recommended. PostgreSQL or MongoDB for persistence. Redis for caching/rate limiting (optional).',
  'Storing secrets in code or env files. Not validating input at API boundary. Missing error handling in async functions. Using global variables instead of DI. Blocking event loop with synchronous operations. Not implementing rate limiting. Keeping passwords in memory after use. Missing HTTPS in production.',
  'Express/Fastify server starts successfully. Requests validated before reaching handlers. Errors caught globally and formatted consistently. JWT tokens verified in middleware. Passwords hashed with bcrypt. Database connections pooled. Rate limiting blocks excessive requests. Cache reduces database hits.',
  'Build scalable Node.js backend services with Express/Fastify, proper architecture, authentication, error handling, and database integration patterns',
  'https://skillsmp.com/skills/wshobson-agents-plugins-javascript-typescript-skills-nodejs-backend-patterns-skill-md',
  'admin:HAIKU_SKILL_1764289714_96235'
);
