-- Add Stack Overflow Solid.js solutions batch 1

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'SolidJS: For vs Index - when to use each component for rendering lists',
    'stackoverflow-solidjs',
    'HIGH',
    '[
        {"solution": "Use <For> component with arrays of objects - caches DOM nodes using item references as keys. When array order changes, same object keeps cached DOM node", "percentage": 90, "note": "Best for dynamic lists with reordering"},
        {"solution": "Use <Index> component with primitive arrays (strings, numbers) - caches DOM nodes by position. More efficient for stable list structures", "percentage": 85, "note": "Calls callback only for new items"},
        {"solution": "Default to <For> when uncertain - it handles both cases safely with proper reactivity", "percentage": 80, "note": "Safer default choice"}
    ]'::jsonb,
    'SolidJS framework installed, Understanding of reactive primitives',
    '<For> or <Index> renders list correctly, DOM updates match array changes, No unexpected re-renders on reorder',
    'Using <Index> with frequently reordered data causes unnecessary re-renders and loses component state like input focus. Primitives refer to array element types, not the array itself.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/70819075/solidjs-for-vs-index'
),
(
    'SolidJS: computations created outside a createRoot or render will never be disposed - console warning',
    'stackoverflow-solidjs',
    'VERY_HIGH',
    '[
        {"solution": "Use /*@once*/ pragma to mark JSX expressions as static rather than reactive. Example: <p>Error: {/*@once*/ result.error}</p>", "percentage": 95, "note": "Official pattern for static content in signals"},
        {"solution": "Store data in signals instead of JSX elements. Use createSignal for data, render in JSX template separately", "percentage": 92, "note": "Fundamental pattern - separates data from presentation"},
        {"solution": "Ensure computations are wrapped in createRoot() or render() establishing proper tracking scope", "percentage": 88, "note": "Prevents context loss in async operations"}
    ]'::jsonb,
    'Understanding of SolidJS reactivity tracking, Knowledge that async functions operate outside rendering context',
    'Console warning disappears, No memory leaks in DevTools, Signals update without disposal warnings',
    'Storing JSX elements directly in signals instead of data. Creating effects inside setTimeout or await blocks without proper owner context. Mixing UI rendering with async operations.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/70373659/solidjs-computations-created-outside-a-createroot-or-render-will-never-be'
),
(
    'SolidJS TypeScript: Property does not exist on type JSX.IntrinsicElements - using web components',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Extend global JSX.IntrinsicElements module in solid-js namespace. Define custom element name (lowercase, hyphenated) with props interface: declare module \"solid-js\" { namespace JSX { interface IntrinsicElements { \"custom-tag\": ComponentProps<\"div\"> & { foo: number } } } }", "percentage": 95, "note": "Standard pattern for web component integration"},
        {"solution": "If component has no custom props, use empty object instead of extending another element: \"custom-tag\": {}", "percentage": 90, "note": "Simplifies type definition for stateless components"},
        {"solution": "Verify custom element script is loaded before rendering the component", "percentage": 85, "note": "Runtime requirement"}
    ]'::jsonb,
    'SolidJS project with TypeScript support, Custom web component already defined/imported',
    'TypeScript compilation succeeds without errors, Custom element renders without type warnings, Props pass through correctly',
    'Wrong syntax - custom element names must be lowercase and hyphenated. Missing props definition when component expects them. Module not found - script loaded after render.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/72238932/how-to-use-a-web-component-in-a-solid-js-project'
),
(
    'SolidJS Router: useNavigate throws Error Make sure your app is wrapped in a Router',
    'stackoverflow-solidjs',
    'HIGH',
    '[
        {"solution": "Call useNavigate() synchronously during component render, not inside event handlers or async callbacks. Move const navigate = useNavigate() to component body before any async operations", "percentage": 95, "note": "Hook requires synchronous context to access router"},
        {"solution": "Ensure Router component wraps entire application in layout component, not just pages", "percentage": 88, "note": "Common wrapper requirement"},
        {"solution": "Use navigate() inside event handler callbacks but call the hook at top level: const navigate = useNavigate(); const login = async () => { navigate(\"/dashboard\") }", "percentage": 90, "note": "Correct hook usage pattern"}
    ]'::jsonb,
    'SolidJS Router installed and configured, Application wrapped in <Router> component',
    'Navigation works inside event handlers without errors, Router context available to component, Page transitions execute successfully',
    'Calling useNavigate() inside async functions or event callbacks instead of at component top level. This breaks hook access to router context established by <Router />.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/72112554/solidjs-router-usenavigate-throws-error-make-sure-your-app-is-wrapped-in-a'
),
(
    'SolidJS TypeScript: How to extend props of JSX elements with custom properties',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Use JSX.HTMLAttributes from solid-js with type intersection: interface ButtonProps extends JSX.ButtonHTMLAttributes<HTMLButtonElement> { title: string }. Use splitProps() to separate custom props: const [local, buttonProps] = splitProps(props, [\"title\"])", "percentage": 95, "note": "Preserves reactivity - destructuring breaks it"},
        {"solution": "Import JSX types from \"solid-js\" not from external DOM library. React patterns differ from SolidJS type locations", "percentage": 90, "note": "Correct import path is critical"},
        {"solution": "Use ParentComponent type instead of Component for components accepting children: const Button: ParentComponent<ButtonProps>", "percentage": 85, "note": "Type changed in v1.4.0+"}
    ]'::jsonb,
    'SolidJS framework installed, TypeScript configured, Understanding of splitProps utility',
    'Component props properly typed, IDE autocomplete works for all props, Child components receive all attributes correctly',
    'Direct destructuring of props like {title} breaks reactivity - use splitProps instead. Component type changed in v1.4.0 - use ParentComponent for children support.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/72126059/typescriptsolidjs-how-can-i-extend-props-of-some-jsx-element'
),
(
    'SolidJS: How to pass multiple refs to child component',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "SolidJS has special ref handling - only first ref prop works automatically. For additional refs, pass explicit callback functions as regular props: <Child ref={sectionRef} ref1={(el) => { headerRef = el }} />", "percentage": 93, "note": "ref is compiled to callback automatically"},
        {"solution": "Define callback function in parent component and pass as prop: const refCallback = (el) => { headerRef = el }; then use ref1={refCallback}", "percentage": 90, "note": "Explicit callback pattern"},
        {"solution": "Access refs inside onMount hook to ensure elements are mounted: onMount(() => { console.log(sectionRef, headerRef) })", "percentage": 88, "note": "Timing requirement for ref access"}
    ]'::jsonb,
    'Understanding of SolidJS component structure, Familiarity with onMount lifecycle hook',
    'Multiple refs assigned correctly, onMount shows both refs populated, DOM elements accessible from parent',
    'Using ref={variable} for non-first refs - use explicit callbacks instead. Passing refs in objects or arrays without callback functions. Assuming multiple ref props work like single ref.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/71135741/how-to-pass-more-than-1-ref-to-a-child-component-in-solidjs'
),
(
    'SolidJS TypeScript: Component types and prop annotations for Solid components',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Use Component<T> generic type with prop interface: const HelloMessage: Component<{name: string}> = (props) => <div>Hello {props.name}</div>", "percentage": 92, "note": "Standard SolidJS type pattern"},
        {"solution": "Alternatively type props directly without Component import: const HelloMessage = (props: { name: string }) => ...", "percentage": 88, "note": "Works but less type-safe"},
        {"solution": "Access props through props.name not destructured {name} - destructuring breaks reactivity in SolidJS", "percentage": 95, "note": "Critical for maintaining signals reactivity"}
    ]'::jsonb,
    'TypeScript configured for JSX, SolidJS installed, Understanding of reactive properties',
    'TypeScript compilation succeeds, Component accepts props without any type, IDE provides autocomplete for prop access',
    'Using destructured props like {name} loses reactivity - access through props.name. Direct prop typing lacks IDE autocompletion in IntelliJ. Component type import may be omitted.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/66065357/typescript-types-for-solid-js-components'
),
(
    'SolidJS: createEffect does not re-run when signal is accessed in setTimeout callback',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Read signal synchronously before setTimeout, not inside the callback. createEffect(() => { const c = count(); setTimeout(() => { setCount(c + 1) }, 1000) })", "percentage": 92, "note": "Simple and effective - captures value before async"},
        {"solution": "Use runWithOwner to create effect in async context: const owner = getOwner(); setTimeout(() => { runWithOwner(owner!, () => { createEffect(...) }) }, 1000)", "percentage": 88, "note": "Advanced pattern for async context preservation"},
        {"solution": "Understand that signal dependencies tracked only during synchronous effect execution. Async operations break tracking context", "percentage": 85, "note": "Fundamental reactivity principle"}
    ]'::jsonb,
    'Understanding of SolidJS reactivity model, Knowledge that signals track synchronously only, getOwner and runWithOwner APIs',
    'Effect runs once and signal value captured, setTimeout executes with correct value, No multiple effect re-runs',
    'Expecting signal reads inside setTimeout to trigger effect re-runs automatically. Not understanding synchronous tracking context. Attempting to access new signal values inside setTimeout callback.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/71227199/why-does-solid-js-createeffect-not-re-run-when-a-signal-is-in-a-settimeout-callb'
),
(
    'SolidJS: Difference between React useState and SolidJS createSignal',
    'stackoverflow-solidjs',
    'HIGH',
    '[
        {"solution": "React uses Virtual DOM - every state update triggers entire component re-render. SolidJS components render once, fine-grained reactivity updates only affected DOM. No component re-execution on state change", "percentage": 94, "note": "Fundamental architecture difference"},
        {"solution": "Signal updates in SolidJS propagate directly through subscribers without re-rendering parent component. React re-runs component function to build new VDOM tree", "percentage": 92, "note": "Performance implication"},
        {"solution": "SolidJS avoids accidental re-renders from descendants and prevents memoization overhead. React requires React.memo or useMemo to prevent unnecessary updates", "percentage": 90, "note": "Mental model simplification"},
        {"solution": "In SolidJS avoid destructuring props - updates won't reflect since component doesn\u0027t re-execute. Access via props.name pattern", "percentage": 88, "note": "Key behavioral difference"}
    ]'::jsonb,
    'Knowledge of React useState API, Understanding of Virtual DOM concept, SolidJS framework experience',
    'SolidJS app updates targeted DOM elements only, Performance metrics show fewer DOM operations, No unnecessary component re-renders in DevTools',
    'Expecting SolidJS to work like React with destructuring props and component re-execution. Assuming both systems require memoization for performance. Using destructured props breaks reactivity.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/75773364/what-is-the-difference-between-usestate-and-createsignal'
),
(
    'SolidJS: Equivalent of React.HTMLProps pattern for typing component props',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Use JSX.IntrinsicElements[\"tag\"] pattern: type Props = JSX.IntrinsicElements[\"a\"] & { to?: string }. Preferred for uniform tag-based access to all HTML attributes", "percentage": 94, "note": "Recommended approach"},
        {"solution": "Use JSX.HTMLAttributes for specific element types: interface Props extends JSX.HTMLAttributes<HTMLAnchorElement> { to?: string }", "percentage": 90, "note": "Alternative approach"},
        {"solution": "Always use splitProps to separate consumed props from spread rest: const [_, ...rest] = splitProps(props, [\"to\"]); then {...rest}", "percentage": 92, "note": "Maintains reactivity"},
        {"solution": "JSX.HTMLAttributes alone won\u0027t include all attributes - use JSX.IntrinsicElements or specific type for complete coverage", "percentage": 88, "note": "Coverage difference between approaches"}
    ]'::jsonb,
    'SolidJS framework installed, TypeScript configured, Knowledge of splitProps utility',
    'Component accepts all standard HTML attributes plus custom props, TypeScript compilation succeeds, IDE autocomplete includes all props',
    'Using JSX.HTMLAttributes without element-specific names for all attributes. Forgetting splitProps causes prop spreading issues. Missing JSX.IntrinsicElements import in some patterns.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/70810158/solid-js-equivalent-of-react-htmlprops'
),
(
    'SolidJS: How to mutate array inside a signal and trigger reactivity',
    'stackoverflow-solidjs',
    'HIGH',
    '[
        {"solution": "Use immutable patterns - create new array instead of mutating: setA(a => [\"hello\", ...a]) or setA(a => [newItem, ...a]). Solid detects reference change triggering updates", "percentage": 95, "note": "Recommended approach - maintains immutability"},
        {"solution": "Set equals: false option to disable referential equality check: let [a, setA] = createSignal([], { equals: false })", "percentage": 88, "note": "Forces update on every set call"},
        {"solution": "Use custom equals function for fine-grained control: createSignal([], { equals: (prev, next) => {...check logic...} })", "percentage": 85, "note": "Advanced control"},
        {"solution": "Wrapper pattern for large arrays - wrap in object to force reference change without full array recreation: let [getter, setter] = createSignal({ internal: [] })", "percentage": 80, "note": "Alternative for 1000+ element lists"}
    ]'::jsonb,
    'Understanding of SolidJS signal API, Knowledge of referential equality, createSignal options',
    'Array mutations trigger component updates, Signal listeners execute when expected, Reactivity works without warnings',
    'Mutating array in place without creating new reference - same reference doesn\u0027t trigger reactivity. Not understanding equals option behavior. Performance concerns with immutable patterns on very large arrays.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/71962713/how-do-i-simply-mutate-the-array-inside-a-signal'
),
(
    'SolidJS: Update local storage values using createSignal and custom hooks',
    'stackoverflow-solidjs',
    'MEDIUM',
    '[
        {"solution": "Create custom hook wrapping createSignal with storage sync. Parse initial value from localStorage and cast setter with \"as\" operator: const createStoredSignal = (key, defaultValue) => { const [value, setValue] = createSignal(...); return [value, setValueAndStore as typeof setValue] }", "percentage": 93, "note": "Type-safe approach with generics"},
        {"solution": "Accept storage parameter for testing: createStoredSignal(key, defaultValue, storage) - defaults to localStorage", "percentage": 90, "note": "Makes hook testable"},
        {"solution": "Use createEffect for automatic sync on changes instead of manual wrapper: createEffect(() => { storage.setItem(key, JSON.stringify(value())) })", "percentage": 88, "note": "Alternative reactive approach"},
        {"solution": "Don\u0027t omit type cast - without \"as typeof setValue\" TypeScript won\u0027t recognize wrapper. Use JSON serialization for all storage types", "percentage": 85, "note": "Implementation requirements"}
    ]'::jsonb,
    'Understanding of SolidJS signals API, TypeScript generics knowledge, Familiarity with JSON serialization',
    'Local storage updates on signal change, Page reload preserves stored values, Type checking passes for setter wrapper',
    'Omitting type cast causes TypeScript errors. Restricting to strings only loses generic flexibility. Not handling undefined values from localStorage.getItem properly.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/70030144/how-to-update-local-storage-values-in-solidjs-using-hooks'
);
