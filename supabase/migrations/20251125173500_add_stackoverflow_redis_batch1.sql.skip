-- Mine Stack Overflow top-voted Redis questions/answers
-- Source: https://stackoverflow.com/questions/tagged/redis?tab=votes
-- Extracted: 11 highest-voted questions with accepted answers
-- Category: stackoverflow-redis

INSERT INTO knowledge_entries (query, category, solutions, common_pitfalls, success_rate, hit_frequency, claude_version, last_verified, thumbs_up)
VALUES
(
  'Memcached vs Redis comparison: which should I use?',
  'stackoverflow-redis',
  '[{"solution": "Choose Redis for new projects as it offers everything Memcached does with superior functionality: multiple data types (strings, hashes, lists, sets, sorted sets, geo-spatial, bitmaps), persistent storage, clustering, Sentinel, Pub/Sub messaging, and Lua scripting support.", "percentage": 95, "note": "Both are equally fast in benchmarks. Redis reclaims unused memory while Memcached retains allocated RAM even after flushing."}, {"solution": "Only choose Memcached if maintaining existing systems already using it effectively, due to its maturity and stability.", "percentage": 70, "note": "Memcached is simpler but limited to strings (max 1MB values) and has no persistence or transactions."}]'::jsonb,
  'Do not select Memcached for new implementations thinking it is faster - benchmarks show Redis matching or exceeding Memcached performance. Memcached''s main advantage (memory allocation predictability) rarely justifies use in modern web apps.',
  0.92,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'How do I delete everything in Redis? FLUSHDB vs FLUSHALL',
  'stackoverflow-redis',
  '[{"solution": "Use FLUSHDB to delete all keys from current database: redis-cli flushdb", "percentage": 95, "command": "redis-cli flushdb", "note": "Recommended for clearing a single database safely."}, {"solution": "Use FLUSHALL to delete all keys from all databases on the server: redis-cli flushall", "percentage": 90, "command": "redis-cli flushall", "note": "Use with caution - affects entire Redis instance, not just one database."}, {"solution": "For Redis 4.0+, use asynchronous variants to avoid blocking: redis-cli flushdb async or redis-cli flushall async", "percentage": 85, "command": "redis-cli flushdb async", "note": "Prevents blocking other operations during large dataset deletion."}, {"solution": "To also remove cached Lua scripts: redis-cli script flush", "percentage": 75, "command": "redis-cli script flush", "note": "Combines script clearing with database flush for complete cleanup."}]'::jsonb,
  'FLUSHALL is overkill if you only need to clear one database - use FLUSHDB instead. These operations permanently delete data with no recovery option - exercise extreme caution in production environments.',
  0.95,
  'VERY_HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'How to atomically delete keys matching a pattern in Redis?',
  'stackoverflow-redis',
  '[{"solution": "Use SCAN-based approach for production (non-atomic but non-blocking): redis-cli --scan --pattern \"*:foo:bar:*\" | xargs -L 100 redis-cli DEL", "percentage": 90, "command": "redis-cli --scan --pattern \"prefix:*\" | xargs -L 100 redis-cli DEL", "note": "Recommended for production. SCAN iterates without blocking database. Use xargs -L 100 to batch deletes."}, {"solution": "Use Lua script for atomicity on small datasets (v2.6.0+): EVAL \"return redis.call(''del'', unpack(redis.call(''keys'', ARGV[1])))\" 0 prefix:*", "percentage": 80, "command": "EVAL \"return redis.call(''del'', unpack(redis.call(''keys'', ARGV[1])))\" 0 prefix:*", "note": "Atomic but fails with thousands of keys. Use batched version for large datasets."}, {"solution": "Avoid simple bash piping (redis-cli KEYS \"prefix:*\" | xargs redis-cli DEL) as it is not atomic - keys created between KEYS and DEL commands won''t be deleted.", "percentage": 70, "note": "Non-atomic - keys created between KEYS and DEL will escape deletion."}]'::jsonb,
  'Do not use KEYS command in production - it blocks database. KEYS + xargs DEL is non-atomic. Lua scripts block on large datasets (thousands+ keys). Always use SCAN for production systems.',
  0.88,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'How to run Redis on Windows?',
  'stackoverflow-redis',
  '[{"solution": "Official recommendation: Use Windows Subsystem for Linux (WSL) on Windows 10/11. Enable WSL with PowerShell: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux, then install Redis: sudo apt-get install redis-server", "percentage": 95, "command": "Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux && sudo apt-get install redis-server", "note": "Best compatibility with native Redis codebase and less maintenance required. Start with: sudo service redis-server restart"}, {"solution": "Alternative: Use Memurai (official successor to deprecated Microsoft port) - free developer tier with memurai.exe server and memurai-cli.exe client, runs as Windows service", "percentage": 85, "note": "Native Windows option but requires separate tool. Official Microsoft port is no longer maintained."}]'::jsonb,
  'Do not use deprecated Microsoft port - maintenance stopped. WSL approach is now strongly preferred. Ensure Linux distribution properly installed before attempting Redis install.',
  0.91,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'Redis command to get all available keys - KEYS * vs SCAN',
  'stackoverflow-redis',
  '[{"solution": "Use SCAN command for production (Redis 2.8+): redis-cli --scan --pattern ''*'' - does not block server nor consume significant resources", "percentage": 95, "command": "redis-cli --scan --pattern ''*''", "note": "Non-blocking, safe for large databases. Iterate cursor-based across all keys."}, {"solution": "Use KEYS * only for development/small databases: KEYS * - WARNING: May ruin performance against large databases by blocking server", "percentage": 60, "command": "redis-cli KEYS ''*''", "note": "Blocking operation - not recommended for production. Simpler syntax but dangerous at scale."}, {"solution": "Select specific database first if keys are in non-zero database: SELECT <database_number>", "percentage": 75, "command": "redis-cli\\nSELECT 1\\nKEYS ''*''", "note": "redis-cli connects to database 0 by default. Use SELECT to switch databases."}, {"solution": "Search specific patterns: KEYS \"prefix:*\" or redis-cli --scan --pattern ''prefix:*''", "percentage": 80, "command": "redis-cli KEYS ''prefix:*''", "note": "KEYS uses glob patterns. Quote asterisk in shell to prevent expansion."}]'::jsonb,
  'Never use KEYS * in production - will block entire server on large datasets. Always quote asterisk in shell (KEYS ''*'') to prevent glob expansion. SCAN is the production-safe choice.',
  0.93,
  'VERY_HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'MISCONF Redis is configured to save RDB snapshots error during writes',
  'stackoverflow-redis',
  '[{"solution": "Restart Redis server - most reliable fix: brew services restart redis (macOS) or sudo systemctl restart redis (Linux) or restart via Windows Services", "percentage": 95, "command": "brew services restart redis", "note": "Reinitializes service properly. Occurs after upgrades or system updates."}, {"solution": "Fix memory/disk issues: echo ''vm.overcommit_memory = 1'' >> /etc/sysctl.conf && sudo sysctl -p /etc/sysctl.conf", "percentage": 80, "command": "echo ''vm.overcommit_memory = 1'' >> /etc/sysctl.conf && sudo sysctl -p", "note": "Allows Redis fork operations for background saves. Required on some Linux systems."}, {"solution": "Fix file permissions: sudo chown -R redis:redis /var/lib/redis", "percentage": 75, "command": "sudo chown -R redis:redis /var/lib/redis", "note": "Ensures Redis process can write to data directory."}, {"solution": "Temporary workaround (NOT for production): redis-cli config set stop-writes-on-bgsave-error no", "percentage": 40, "command": "redis-cli config set stop-writes-on-bgsave-error no", "note": "Masks persistence problem - only use for troubleshooting. Does not fix root cause."}]'::jsonb,
  'Restart is the proper fix - do not just disable stop-writes-on-bgsave-error unless troubleshooting. This error indicates persistence/permissions problem that needs addressing. Temporary workaround masks underlying issue.',
  0.91,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'How can I stop redis-server?',
  'stackoverflow-redis',
  '[{"solution": "Cross-platform method: Use redis-cli shutdown command - synchronously saves dataset to disk and shuts down server", "percentage": 95, "command": "redis-cli shutdown", "note": "Works regardless of Redis installation method. Graceful shutdown with persistence."}, {"solution": "Linux init.d script: /etc/init.d/redis-server stop or restart or start", "percentage": 90, "command": "/etc/init.d/redis-server stop", "note": "Traditional method on Ubuntu/Debian with package manager installation."}, {"solution": "Modern systemd (Ubuntu/Debian): sudo service redis-server stop or sudo systemctl stop redis", "percentage": 90, "command": "sudo systemctl stop redis", "note": "Preferred on modern systems with systemd."}, {"solution": "macOS Homebrew: brew services stop redis", "percentage": 90, "command": "brew services stop redis", "note": "Convenient for macOS installations via Homebrew."}]'::jsonb,
  'redis-cli shutdown is most universally applicable - works on any installation method. Traditional /etc/init.d scripts may not exist on modern systems using systemd. Always verify process stopped with ps aux | grep redis.',
  0.94,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'When to use Redis vs MongoDB for data storage?',
  'stackoverflow-redis',
  '[{"solution": "Use Redis as high-performance caching layer and for key-value storage when speed is critical: extremely fast, fits naturally into key-value pairs, requires sufficient RAM", "percentage": 90, "note": "Redis is in-memory with RAM constraints. Ideal for caching reads and real-time operations."}, {"solution": "Use MongoDB for flexible data modeling, rapid prototyping, and complex nested documents: schema flexibility during development, complex querying, disk-based scaling", "percentage": 85, "note": "Handles larger datasets naturally. Better for developer velocity in early stages."}, {"solution": "Hybrid approach: Use MongoDB as primary database with Redis as caching layer for frequently accessed data", "percentage": 95, "note": "Best of both worlds - MongoDB for persistence/complexity, Redis for speed. Many modern architectures use this pattern."}, {"solution": "Choose Redis if you need really high performance and have time to optimize data structures. Choose MongoDB if data structure involves complex nested documents.", "percentage": 85, "note": "Redis requires careful optimization. MongoDB trades some performance for ease of development."}]'::jsonb,
  'Do not use Redis for data that exceeds available RAM - it will fail. Do not use MongoDB when extreme speed is critical without adding Redis caching layer. MongoDB''s flexibility comes at performance cost.',
  0.87,
  'MEDIUM',
  'sonnet-4',
  NOW(),
  0
),
(
  'Redis strings vs Redis hashes to represent JSON: which is more efficient?',
  'stackoverflow-redis',
  '[{"solution": "Store as JSON string (Option 1) when: you access most fields on each retrieval, JSON structure has nested objects, need atomic operations on entire objects. Fast JSON parsing when accessing multiple fields.", "percentage": 85, "note": "Considered best practice but causes race conditions if concurrent modification expected."}, {"solution": "Store as hash (Option 2) when: you frequently access individual fields only, all field names are known, values have predictable sizes. No JSON parsing needed, efficient for partial field access.", "percentage": 80, "note": "Simpler field-level operations but can lose memory efficiency if hash-max-ziplist limits exceeded."}, {"solution": "Critical caveat: JSON strings are bad for concurrent modification - classic read-modify-write race condition. Must read entire JSON, parse, modify, serialize, write back - not atomic.", "percentage": 95, "note": "Hashes allow atomic field-level operations. Use strings only for read-heavy workloads."}, {"solution": "Monitor hash-max-ziplist-value and hash-max-ziplist-entries Redis configuration - when limits exceeded, hashes convert to standard key-value pairs adding ~70 bytes per field, negating memory advantage", "percentage": 75, "note": "Hash efficiency is configuration-dependent. Large hashes lose memory benefits."}]'::jsonb,
  'Do not use JSON strings for concurrent modifications without locking - read-modify-write is not atomic. Do not assume hashes are always more efficient - configuration limits matter. Choose based on access patterns, not just storage size.',
  0.86,
  'MEDIUM',
  'sonnet-4',
  NOW(),
  0
),
(
  'Redis WRONGTYPE error: Operation against a key holding the wrong kind of value',
  'stackoverflow-redis',
  '[{"solution": "Use TYPE command to identify what data type a key actually stores: TYPE <key> - returns string, hash, list, set, zset, or none", "percentage": 95, "command": "TYPE mykey", "note": "First step in debugging WRONGTYPE errors. Reveals actual stored type."}, {"solution": "Use correct command for identified data type: GET for string, HGETALL for hash, LRANGE for list, SMEMBERS for set, ZSCORE for sorted set", "percentage": 95, "note": "Each data type has specific commands. Mixing commands causes WRONGTYPE error."}, {"solution": "Common cause: key previously stored one data type but code attempts to access as another. For example: SET key ''value'' creates string, then HSET key field value fails because key is string not hash", "percentage": 90, "note": "Type mismatches often happen in long-running apps where data evolves. Must delete and recreate with correct type."}, {"solution": "Solution: DEL the key first if storing different type, or use different key name for different data structure", "percentage": 85, "command": "DEL mykey", "note": "Clean slate avoids type confusion. Or use namespacing like mykey:string vs mykey:hash for clarity."}]'::jsonb,
  'Do not assume key type - always use TYPE command to verify before operations. Do not reuse same key name for different data types without deleting first. Data type mismatch is a common integration bug.',
  0.92,
  'HIGH',
  'sonnet-4',
  NOW(),
  0
),
(
  'What are the underlying data structures used in Redis?',
  'stackoverflow-redis',
  '[{"solution": "Strings use dynamic string library enabling efficient append operations with O(N) complexity rather than quadratic behavior. Applications: text storage, JSON/MessagePack objects, bitmaps, random-access byte arrays.", "percentage": 90, "note": "Strings are optimized for append-heavy workloads. Support bit operations natively."}, {"solution": "Lists are implemented with linked lists for operations affecting head or tail. Applications: queues, stacks, ring rotations via RPOPLPUSH. O(1) head/tail operations.", "percentage": 85, "note": "Linked list structure means O(N) for middle access but O(1) for push/pop at ends."}, {"solution": "Sets and Hashes both use hash tables for O(1) lookup. Sets: membership verification, uniqueness, unions/intersections. Hashes: object representation, memory-optimized key-value collections.", "percentage": 90, "note": "Hash tables provide constant-time lookups. Sets add no ordering overhead."}, {"solution": "Sorted Sets use skip lists (probabilistic balanced tree alternatives) enabling O(log N) range queries and ordering by user-defined scores. Applications: leaderboards, priority queues, paginated collections.", "percentage": 85, "note": "Skip lists simpler than B-trees but provide similar O(log N) performance."}, {"solution": "Redis optimizes small datasets with compact encodings storing data inline, trading CPU for memory efficiency - O(N) scans acceptable due to cache-friendly access patterns.", "percentage": 80, "note": "Encoding optimization matters for small collections. Monitor with OBJECT ENCODING command."}]'::jsonb,
  'Do not assume Redis data structures behave like programming language equivalents - understanding actual implementations helps optimize performance. String append is O(N) amortized, not O(1). List operations on middle elements are O(N).',
  0.89,
  'MEDIUM',
  'sonnet-4',
  NOW(),
  0
);
