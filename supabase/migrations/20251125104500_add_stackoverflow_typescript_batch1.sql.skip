-- Add Stack Overflow top voted TypeScript questions/answers batch 1

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'What is the difference between interface and type in TypeScript?',
    'stackoverflow-typescript',
    'VERY_HIGH',
    '[
        {"solution": "Use interfaces for object type definitions - they support declaration merging, are cached by compiler, and provide terser error messages", "percentage": 95, "note": "Preferred for object shapes"},
        {"solution": "Use type aliases for primitives, unions, and tuples - type Name = string | number", "percentage": 90, "note": "Type aliases offer greater flexibility"},
        {"solution": "Interfaces can extend other interfaces: interface Child extends Parent {}", "percentage": 85, "command": "Both support the extends keyword, type uses & for intersection"},
        {"solution": "Interfaces support declaration merging - multiple declarations combine into one interface", "percentage": 90, "note": "Type aliases will error if redeclared"}
    ]'::jsonb,
    'TypeScript knowledge, understanding of type system',
    'Code compiles without errors, type checking works as expected in IDE',
    'Interfaces are cached by compiler while type aliases are recomputed. For large projects, prefer interfaces. Mixing both for same type creates confusion.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript'
),
(
    'What is TypeScript and why should I use it instead of JavaScript?',
    'stackoverflow-typescript',
    'VERY_HIGH',
    '[
        {"solution": "Use TypeScript for optional static typing - catch errors at compile-time instead of runtime: var x: string = 123 throws error", "percentage": 95, "note": "Acts as your first unit test"},
        {"solution": "Enable strict null checks with --strictNullChecks flag to eliminate cannot read property of undefined errors", "percentage": 90, "command": "--strictNullChecks flag in tsconfig.json"},
        {"solution": "Write modern JavaScript (ES6+) and compile to older versions for backward compatibility", "percentage": 88, "note": "Use target option in tsconfig.json"},
        {"solution": "Leverage superior IDE integration for intellisense, code completion, and safe refactoring across entire codebases", "percentage": 85, "note": "Real-time compilation feedback helps identify issues while coding"}
    ]'::jsonb,
    'Basic JavaScript knowledge, TypeScript compiler installed',
    'Code compiles with fewer runtime errors, IDE provides accurate autocompletion, type mismatches caught at compile time',
    'TypeScript adds compile-time overhead but prevents runtime type errors. Studies show statically-typed languages have lower defect rates.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/12694530/what-is-typescript-and-why-should-i-use-it-instead-of-javascript'
),
(
    'How to convert a string to number in TypeScript?',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "Use unary plus operator: var y: number = +x; where x is a string", "percentage": 95, "note": "Most concise and performant"},
        {"solution": "Use Number() constructor: Number(''1234'') returns 1234, Number(''9BX9'') returns NaN", "percentage": 90, "note": "Clear intent but slightly more verbose"},
        {"solution": "Use parseInt() with explicit radix: parseInt(''123'', 10) for base-10 integers", "percentage": 85, "command": "Always specify radix to avoid octal interpretation"},
        {"solution": "Use parseFloat() for decimal numbers: parseFloat(''123.45'') returns 123.45", "percentage": 80, "note": "Note: +null returns 0, parseInt(null) returns NaN"}
    ]'::jsonb,
    'TypeScript basic knowledge, string variable',
    'Result is of type number, typeof result === "number"',
    'Integer conversions: +null returns 0 but is falsy. parseFloat() loses precision with very large numbers. Always validate NaN results.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/14667713/how-to-convert-a-string-to-number-in-typescript'
),
(
    'What is the ! (exclamation mark / bang) operator in TypeScript?',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "The ! is the non-null assertion operator - tells TypeScript a value cannot be null/undefined: node.parent!", "percentage": 95, "note": "Compile-time only, no runtime effect"},
        {"solution": "Use when TypeScript''s type inference fails but you have certainty the value exists", "percentage": 90, "note": "Example: if (element!) { ... }"},
        {"solution": "The operator is removed during transpilation - only affects type checking", "percentage": 85, "command": "Transpiled JavaScript removes the ! entirely"},
        {"solution": "Use cautiously - misusing it leads to runtime errors TypeScript would otherwise catch", "percentage": 80, "note": "It''s an override, not a guarantee"}
    ]'::jsonb,
    'TypeScript knowledge, understanding of null/undefined types',
    'Code compiles without type errors, property access works at runtime',
    'The ! operator is your assertion that a value exists - if wrong, it fails at runtime. Only use when absolutely certain. Consider using optional chaining (?.) or type guards instead.',
    0.87,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/42273853/in-typescript-what-is-the-exclamation-mark-bang-operator-when-dereferencing-in-code'
),
(
    'Cannot bind to formGroup since it is not a known property of form - Angular TypeScript error',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "Import ReactiveFormsModule in your module: import { ReactiveFormsModule } from @angular/forms and add to imports array", "percentage": 95, "note": "Most common cause"},
        {"solution": "Ensure both FormsModule and ReactiveFormsModule are imported in the module, not just one", "percentage": 90, "note": "Some only import FormsModule"},
        {"solution": "Add ReactiveFormsModule to every feature/child module that uses form directives", "percentage": 88, "command": "Each module needs its own imports"},
        {"solution": "Verify template uses [formGroup] binding and elements have formControlName attributes", "percentage": 85, "note": "Without formControlName, binding fails"}
    ]'::jsonb,
    'Angular project, @angular/forms package installed, TypeScript module setup',
    'Template compiles without errors, form controls bind properly, formGroup directive is recognized',
    'Forgetting to import ReactiveFormsModule is most common error. Case sensitivity matters: [formGroup] not [FormGroup]. Each module needs its own imports. Template must use formControlName for individual controls.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/39152071/cant-bind-to-formgroup-since-it-isnt-a-known-property-of-form'
),
(
    'How to explicitly set a new property on window object in TypeScript?',
    'stackoverflow-typescript',
    'MEDIUM',
    '[
        {"solution": "Use declaration merging with global interface: declare global { interface Window { MyNamespace: any; } }", "percentage": 95, "note": "Maintains type safety"},
        {"solution": "Assign property after extending: window.MyNamespace = window.MyNamespace || {};", "percentage": 92, "note": "Prevents overwriting existing properties"},
        {"solution": "In JSX files use casting instead of angle brackets: (window as any).MyNamespace to avoid JSX interpretation", "percentage": 88, "note": "< > syntax conflicts with JSX"},
        {"solution": "Use dynamic access for flexibility: window[''MyNamespace''] works but may trigger linting warnings", "percentage": 70, "note": "Less preferred, loses type safety"}
    ]'::jsonb,
    'TypeScript project, understanding of declaration merging and global scope',
    'Property accessible as window.MyNamespace, TypeScript type checker recognizes it, no compilation errors',
    'In .d.ts files, may need export {} to ensure module recognition. Angle bracket syntax < any > conflicts with JSX. Dynamic access loses type safety benefits.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/12709074/how-do-you-explicitly-set-a-new-property-on-window-in-typescript'
),
(
    'Could not find a declaration file for module - TypeScript error',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "For your own npm package: set main and types fields in package.json: {\"main\": \"dist/index\", \"types\": \"dist/index\"}", "percentage": 95, "note": "Omit .js and .d.ts extensions"},
        {"solution": "Ensure tsconfig.json has declaration: true to generate .d.ts files automatically", "percentage": 93, "command": "Check compilerOptions.declaration setting"},
        {"solution": "Clear dist folder and reinstall dependencies - stale files can cause module resolution issues", "percentage": 88, "note": "Common with incremental builds"},
        {"solution": "For third-party packages without types: install @types/package-name from npm", "percentage": 85, "command": "npm install --save-dev @types/package-name"}
    ]'::jsonb,
    'npm package published or being developed, TypeScript compiler configured, dist output exists',
    'TypeScript finds .d.ts files, no type errors reported, module imports work correctly',
    'Forgetting types field in package.json is common. Declaration option must be true in tsconfig. Third-party packages need @types/package-name for type support.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/41292559/could-not-find-a-declaration-file-for-module-module-name'
),
(
    'Property has no initializer and is not definitely assigned in the constructor - TypeScript error',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "Initialize property at declaration: makes: any[] = [] instead of just makes: any[]", "percentage": 95, "note": "Preferred approach for type safety"},
        {"solution": "Use definite assignment assertion operator: makes!: any[] to tell compiler value is initialized", "percentage": 88, "note": "Still recommended to initialize in constructor"},
        {"solution": "Initialize in constructor: constructor() { this.makes = []; }", "percentage": 90, "note": "Safe and explicit"},
        {"solution": "Disable strict property initialization in tsconfig.json: \"strictPropertyInitialization\": false", "percentage": 60, "note": "Not recommended - reduces type safety"}
    ]'::jsonb,
    'TypeScript 2.7+, class-based component, strict mode enabled',
    'Property initialized before use, no compiler errors, code executes without undefined errors',
    'Disabling strictPropertyInitialization reduces TypeScript''s effectiveness. The ! operator is an assertion - if wrong, fails at runtime. Always initialize properties for production code.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/49699067/property-has-no-initializer-and-is-not-definitely-initialized-in-the-constructor'
),
(
    'How to use get and set accessors (getters and setters) in TypeScript?',
    'stackoverflow-typescript',
    'MEDIUM',
    '[
        {"solution": "Use get and set keywords: get bar(): boolean { return this._bar; } set bar(value: boolean) { this._bar = value; }", "percentage": 95, "note": "Standard syntax"},
        {"solution": "Compile to ECMAScript 5 or higher using --target ES5 flag in TypeScript compiler", "percentage": 90, "command": "Configure in tsconfig.json: \"target\": \"ES5\""},
        {"solution": "Use backing field with underscore prefix: private _bar to store actual value", "percentage": 92, "note": "Convention for getter/setter pairs"},
        {"solution": "Access like properties without parentheses: myFoo.bar = true; calls setter, var value = myFoo.bar; calls getter", "percentage": 95, "note": "Syntax looks like property access"}
    ]'::jsonb,
    'TypeScript project, ES5+ target support, class-based code',
    'Accessors callable without method syntax, compiled JavaScript uses Object.defineProperty(), private backing field works correctly',
    'Requires ES5+ target - older targets do not support getters/setters. Must target ES5 or higher. Use underscore prefix for backing field by convention to avoid naming conflicts.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/12827266/get-and-set-in-typescript'
),
(
    'When to use JSX.Element vs ReactNode vs ReactElement in React TypeScript?',
    'stackoverflow-typescript',
    'HIGH',
    '[
        {"solution": "Use ReactElement for JSX expressions and React.createElement() calls - it has type, props, and key properties", "percentage": 92, "note": "Actual type returned by JSX"},
        {"solution": "Use JSX.Element as an alias to ReactElement<any, any> - TypeScript hook for JSX type compatibility", "percentage": 90, "note": "Works across different React libraries"},
        {"solution": "Use ReactNode for children props and broad component return types - encompasses ReactElement, string, number, boolean, null, undefined, Fragment, Portal", "percentage": 95, "note": "Broadest type"},
        {"solution": "For functional components that may return nothing: const MyComp = (): JSX.Element | null => condition ? <div/> : null", "percentage": 88, "note": "Allows explicit null returns"}
    ]'::jsonb,
    'React project with TypeScript, understanding of component types',
    'Component renders correctly, type checking accepts valid JSX, children accept various content types',
    'Class render() returns ReactNode while functional components return ReactElement | null - different by historical design. Use ReactNode for children to accept strings, fragments, and other types.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement'
),
(
    'What does "not assignable to parameter of type never" error mean in TypeScript?',
    'stackoverflow-typescript',
    'MEDIUM',
    '[
        {"solution": "Explicitly type empty arrays: const result: string[] = []; instead of const result = []", "percentage": 95, "note": "Most direct solution"},
        {"solution": "Use type assertion: const result = [] as string[] to explicitly cast empty array", "percentage": 90, "note": "Alternative to inline type annotation"},
        {"solution": "For React useState: use generic type: useState<string[]>([]) to specify array element type", "percentage": 92, "command": "useState<string[]>([]) instead of useState([])"},
        {"solution": "TypeScript infers empty arrays as never[] under strictNullChecks without noImplicitAny - never type rejects all values", "percentage": 88, "note": "Explains why you cannot push values"}
    ]'::jsonb,
    'TypeScript with strictNullChecks enabled, array variable, push() operation',
    'Array accepts pushed values, typeof result === "number[], no type errors on push()',
    'Empty arrays inferred as never[] when strictNullChecks is enabled. Always specify array types explicitly. The never type represents impossible values - nothing can be assigned to it.',
    0.87,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/52423842/what-is-not-assignable-to-parameter-of-type-never-error-in-typescript'
),
(
    'How to dynamically assign properties to an object in TypeScript?',
    'stackoverflow-typescript',
    'MEDIUM',
    '[
        {"solution": "Use index signature in interface: interface LooseObject { [key: string]: any } then var obj: LooseObject = {}; obj.prop = ''value'';", "percentage": 95, "note": "Type-safe dynamic properties"},
        {"solution": "Use Record utility type: var obj: Record<string, any> = {}; equivalent to index signature but more readable", "percentage": 92, "note": "Modern TypeScript approach"},
        {"solution": "Use inline index signature: var obj: {[k: string]: any} = {}; for quick typing", "percentage": 88, "note": "Compact syntax"},
        {"solution": "Mix typed and dynamic properties: interface MyType { requiredProp: string; [key: string]: any } preserves type checking for known props", "percentage": 90, "note": "Best for partial type safety"}
    ]'::jsonb,
    'TypeScript project, need for dynamic property assignment, understanding of interfaces',
    'Dynamic properties assignable without type errors, known properties maintain type safety, IDE provides autocompletion for typed properties',
    'Index signature [key: string]: any allows dynamic assignment but loses type safety. Record utility type cleaner than index signatures. Can combine typed properties with dynamic [key: string]: any for flexibility.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/12710905/how-do-i-dynamically-assign-properties-to-an-object-in-typescript'
);
