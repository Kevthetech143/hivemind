-- Stack Overflow top-voted Bash/shell scripting solutions batch 1
-- Source: https://stackoverflow.com/questions/tagged/bash?tab=votes
-- Category: stackoverflow-bash
-- Extracted 2025-11-25

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'How do I get the directory where a Bash script is located from within the script itself?',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Use the reliable one-liner: SCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )", "percentage": 95, "note": "Works regardless of how script is invoked, handles relative/absolute paths"},
        {"solution": "Use dirname with BASH_SOURCE for sourced scripts: dirname \"${BASH_SOURCE[0]}\"", "percentage": 85, "note": "Simpler but may return relative path like ."},
        {"solution": "For absolute path with symlink resolution: dirname \"$(readlink -f \"$0\")\"", "percentage": 80, "note": "May not work on older macOS versions where readlink -f unavailable"}
    ]'::jsonb,
    'Bash shell, Script file readable',
    'SCRIPT_DIR variable contains absolute path to script directory, works when script called from different directories',
    'Do not use $0 for sourced scripts - use ${BASH_SOURCE[0]} instead. Symlink resolution may fail on non-GNU systems.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/59895'
),
(
    'How do I check if a directory exists or not in a Bash shell script?',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Use -d test operator: if [ -d \"$DIRECTORY\" ]; then echo directory exists; fi", "percentage": 95, "note": "Standard POSIX approach, works across all shells"},
        {"solution": "Use negation operator to check if NOT exists: if [ ! -d \"$DIRECTORY\" ]; then echo not found; fi", "percentage": 95, "note": "Commonly used for early exit logic"},
        {"solution": "For bash-specific scripts, use double brackets with logical operators: if [[ -d \"${DIRECTORY}\" && ! -L \"${DIRECTORY}\" ]]; then echo real directory; fi", "percentage": 85, "note": "Distinguishes symlinks from real directories"}
    ]'::jsonb,
    'Bash shell, Valid directory path or variable',
    'Conditional evaluates correctly, directory check returns expected result',
    'Always quote variables to handle spaces in directory names: [ -d \"$DIR\" ] not [ -d $DIR ]. Watch for symlinks - -d returns true for symlink targets.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/59838'
),
(
    'How do I tell if a file does not exist in Bash?',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Use negation with -f test: if [ ! -f /tmp/foo.txt ]; then echo \"File not found!\"; fi", "percentage": 95, "note": "Inverts logic of file existence check"},
        {"solution": "Use compact one-liner: [ -f \"$file\" ] || echo \"File not found!\"", "percentage": 90, "note": "Leverages logical OR operator for concise syntax"},
        {"solution": "Use -e to check any file type (not just regular files): if [ ! -e \"$file\" ]; then echo missing; fi", "percentage": 85, "note": "Also matches directories, sockets, symlinks"}
    ]'::jsonb,
    'Bash shell, Valid file path or variable',
    'Condition evaluates correctly, script branches properly on file existence',
    'Always quote variables to handle filenames with spaces. Use -f for regular files only, -e for any type. Test with actual files to verify.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/638975'
),
(
    'Echo newline in Bash prints literal backslash-n',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use printf instead of echo for portability - printf interprets escape sequences consistently", "percentage": 95, "note": "Behaves consistently across different environments, most portable"},
        {"solution": "Use echo with ANSI-C quoting in bash: use dollar sign before single quotes to enable escape sequences", "percentage": 90, "note": "Bash-specific syntax, treats backslash escapes per ANSI C standard"},
        {"solution": "Avoid echo -e flag - behavior varies by system, some versions ignore it entirely", "percentage": 85, "note": "Unreliable across different Unix variants"}
    ]'::jsonb,
    'Bash shell or POSIX shell with printf available',
    'Output correctly displays newline characters, not literal backslash-n text',
    'Do not rely on echo -e - it has inconsistent behavior. printf is more portable. In bash, dollar-quote syntax is also reliable.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/8467424'
),
(
    'How to check if a string contains a substring in Bash',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Use double brackets with wildcard pattern: if [[ $string == *\"substring\"* ]]; then echo found; fi", "percentage": 95, "note": "Most popular, readable, and efficient bash-specific approach"},
        {"solution": "Use case statement for POSIX compatibility: case \"$string\" in *foo*) echo found;; esac", "percentage": 90, "note": "Portable across shells, 2-8x faster than parameter expansion"},
        {"solution": "Use regex matching in bash: if [[ $string =~ \"regex\" ]]; then echo found; fi", "percentage": 85, "note": "Powerful for complex patterns, bash-specific"}
    ]'::jsonb,
    'Bash shell (or POSIX shell for case statement method), strings to compare',
    'Conditional evaluates correctly, substring found or not found as expected',
    'Use case statement for fastest performance. Spaces in substring need quotes around the pattern: [[ $str == *\"with space\"* ]]. Do not use grep for performance-critical code.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/229551'
),
(
    'How to concatenate string variables in Bash',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Place variables adjacent with expansion: var=\"${var} World\" or c=\"${a} ${b}\"", "percentage": 95, "note": "Simple and portable, works across shells"},
        {"solution": "Use += operator for appending: A=\"X Y\"; A+=\" Z\"", "percentage": 90, "note": "Clean syntax but Bash-specific, does not work in POSIX sh"},
        {"solution": "Use curly braces when appending immediately without space: var=\"${var}World\"", "percentage": 85, "note": "Prevents shell from looking for $varWorld variable"}
    ]'::jsonb,
    'Bash shell, string variables defined',
    'Concatenated string contains all parts in correct order, output matches expected',
    'Do NOT use var=\"$varWorld\" - the shell will look for variable $varWorld not $var. Use ${var}World instead. += operator only in bash, not POSIX sh.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/4181703'
),
(
    'What does \"2>&1\" mean in Bash?',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Redirect stderr (fd 2) to stdout (fd 1): command > file.txt 2>&1", "percentage": 95, "note": "The & indicates file descriptor, not filename. Order matters - left to right processing."},
        {"solution": "Pipe both stdout and stderr: g++ main.cpp 2>&1 | head", "percentage": 90, "note": "Combine stderr and stdout into single stream for piping"},
        {"solution": "Use modern shorthand for both streams: command &> file.txt", "percentage": 85, "note": "Equivalent to 2>&1 > but more readable, available in bash"}
    ]'::jsonb,
    'Bash shell, understanding of file descriptors',
    'Command output and errors appear in expected location, redirection works correctly',
    'Without & symbol, 2>1 creates literal file named \"1\" - always use 2>&1. Order matters: > file 2>&1 differs from 2>&1 > file. Left-to-right redirection processing.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/818255'
),
(
    'How can I check if a program exists from a Bash script?',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use POSIX-compliant command -v: if ! command -v <program> >/dev/null 2>&1; then echo not found; fi", "percentage": 95, "note": "Shell builtin, faster than external commands, portable and reliable"},
        {"solution": "For bash-specific scripts use hash: hash <program> 2>/dev/null || { echo not found; exit 1; }", "percentage": 85, "note": "Checks if program was previously executed and cached"},
        {"solution": "If full path known, use test operator: [ -x /path/to/program ] && echo exists", "percentage": 80, "note": "Only works when absolute path is known"}
    ]'::jsonb,
    'Bash shell, program name or full path',
    'Command returns correct exit status, conditional evaluates as expected',
    'Avoid using which - inconsistent across operating systems. command -v is POSIX standard. Suppress output with >/dev/null 2>&1 to check only exit status.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/592620'
),
(
    'How do I split a string on a delimiter in Bash?',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use read with IFS (Internal Field Separator) set to delimiter, then read into array with -ra flag", "percentage": 95, "note": "Most reliable, handles embedded spaces and special characters. IFS scope automatically limited."},
        {"solution": "Use parameter expansion for simple cases with delimiter replacement", "percentage": 75, "note": "Concise but triggers word-splitting and glob expansion, fails with spaces or special chars"},
        {"solution": "Avoid using cut or awk for simple string splitting", "percentage": 70, "note": "External commands add overhead"}
    ]'::jsonb,
    'Bash shell, input string with delimiter',
    'String splits correctly into array elements, output matches expected tokens',
    'Parameter expansion method breaks with embedded spaces. Use read method for production code. IFS change with read is automatically scoped.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/918886'
),
(
    'Extract filename and extension in Bash',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use POSIX parameter expansion: filename=$(basename -- \"$fullfile\"); extension=\"${filename##*.}\"; filename=\"${filename%.*}\"", "percentage": 95, "note": "Most robust, handles files like example.tar.gz correctly. -- prevents dash-prefix misinterpretation."},
        {"solution": "Understand parameter expansion operators: ${var%%.*} greedy start, ${var%.*} shortest end, ${var##*.} longest start", "percentage": 90, "note": "For example.tar.gz: %%.* gives example, ##*. gives gz"},
        {"solution": "Handle edge case of files without extensions: extension=$([[ \"$filename\" = *.* ]] && echo \".${filename##*.}\" || echo '''')", "percentage": 85, "note": "Returns empty string if no extension found"}
    ]'::jsonb,
    'Bash shell, filename with or without extension',
    'Filename and extension extracted separately and correctly, hidden files handled properly',
    'Use basename -- to prevent filenames starting with dashes from misinterpretation. For .gitignore type files, convention matters on what is extension.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/965053'
),
(
    'How do I parse command line arguments in Bash?',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use while loop with case for flexible parsing: while [[ $# -gt 0 ]]; do case $1 in -e|--extension) EXTENSION=\"$2\"; shift 2;; esac; done", "percentage": 95, "note": "Most flexible native bash solution, supports long and short options"},
        {"solution": "Use POSIX getopts for maximum portability: while getopts \"hvf:\" opt; do case \"$opt\" in v) verbose=1;; f) output_file=$OPTARG;; esac; done", "percentage": 90, "note": "Portable across shells, works in dash and other POSIX shells"},
        {"solution": "Support equals-separated format: script.sh --option=value using parameter expansion", "percentage": 85, "note": "Alternative to space-separated arguments"}
    ]'::jsonb,
    'Bash shell, command-line arguments provided',
    'All arguments parsed correctly, variables set to expected values, positional arguments preserved',
    'getopts more portable than manual parsing. Shift $((OPTIND-1)) to handle remaining positional arguments. Test with edge cases like option at end.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/192249'
),
(
    'How to check if a variable is set in Bash',
    'stackoverflow-bash',
    'HIGH',
    '[
        {"solution": "Use parameter expansion to distinguish unset from empty: if [ -z ${var+x} ]; then echo unset; else echo set; fi", "percentage": 95, "note": "${var+x} expands to nothing if unset, to x if set even if empty"},
        {"solution": "To check if blank (empty or unset): if [ -z \"$var\" ]; then echo blank; fi", "percentage": 85, "note": "Does not distinguish between unset and empty string"},
        {"solution": "For function arguments, check if first parameter provided: if [ -z ${1+x} ]; then echo no arg; fi", "percentage": 90, "note": "Works with strict mode set -eu"}
    ]'::jsonb,
    'Bash shell, variable to check',
    'Variable status determined correctly (unset vs set vs empty), conditional evaluates properly',
    'Always quote variables [ -z \"${var+x}\" ] for maximum safety. Simple [ -z \"$var\" ] treats empty and unset the same. Use +x expansion for distinction.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/3601515'
),
(
    'How do I set a variable to the output of a command in Bash?',
    'stackoverflow-bash',
    'VERY_HIGH',
    '[
        {"solution": "Use command substitution with $(): OUTPUT=\"$(command)\"; echo \"$OUTPUT\"", "percentage": 95, "note": "Modern syntax, allows nesting, preserves multi-line output when quoted"},
        {"solution": "Avoid legacy backtick syntax: OUTPUT=`command` (obsolete, harder to nest)", "percentage": 85, "note": "Old style, now discouraged in favor of $()"},
        {"solution": "Always quote the variable when echoing: echo \"$OUTPUT\" to preserve whitespace and newlines", "percentage": 90, "note": "Unquoted variables trigger word-splitting"}
    ]'::jsonb,
    'Bash shell, command that produces output',
    'Variable contains command output, output displays correctly with proper whitespace preservation',
    'Single quotes prevent substitution - use double quotes or $() syntax. No spaces around = in assignment. Quote variables to preserve formatting.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://stackoverflow.com/questions/4651437'
);
