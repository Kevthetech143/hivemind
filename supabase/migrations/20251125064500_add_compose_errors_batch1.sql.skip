-- Add Jetpack Compose common errors and solutions batch 1

INSERT INTO knowledge_entries (query, category, hit_frequency, solutions, prerequisites, success_indicators, common_pitfalls, success_rate, claude_version, last_verified, source_url)
VALUES
(
  'Jetpack Compose state hoisting causes excessive recompositions',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Hoist state to the lowest common ancestor that uses it - do not hoist to parent if only child needs it", "percentage": 95, "note": "Keep state as close to consumption as possible to minimize recomposition scope"},
    {"solution": "For UI state like scroll position, keep in composables/state holders, not in ViewModels", "percentage": 90, "note": "ViewModels are for business logic state, not UI element state - lifecycle mismatch causes bugs"},
    {"solution": "Use plain state holder classes instead of over-complex composable functions", "percentage": 85, "note": "Separates state management from UI emission for better testing and recomposition control"}
  ]'::jsonb,
  'Understanding Compose mental model, State class knowledge',
  'Recomposition count reduced in Android Studio Profiler, Component re-renders only when relevant state changes',
  'Passing state through multiple nested composables when only leaf needs it (property drilling). Storing UI state like scroll position in ViewModels.',
  0.92,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/state-hoisting'
),
(
  'Jetpack Compose modifier order affects layout and interaction behavior',
  'jetpack-compose',
  'VERY_HIGH',
  '[
    {"solution": "Place padding modifier BEFORE clickable: Modifier.clickable().padding() to make padded area clickable", "percentage": 95, "note": "Modifier order is significant - reversing order makes only unpadded area clickable"},
    {"solution": "For size constraints, use requiredSize() instead of size() to bypass parent constraints", "percentage": 90, "note": "size() respects parent constraints and may be ignored if they conflict"},
    {"solution": "Ensure scoped modifiers used in correct scope: matchParentSize in BoxScope, weight in RowScope/ColumnScope", "percentage": 85, "note": "Scoped modifiers silently ignored outside intended scope - no compile error"}
  ]'::jsonb,
  'Familiarity with Modifier API, Basic Compose layout knowledge',
  'Click target includes padded area in Inspection, Layout respects specified size override, Modifier applied without runtime warnings',
  'Applying modifiers in wrong order without understanding they are not commutative. Using scoped modifiers outside their intended layout scope expecting runtime error.',
  0.93,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/modifiers'
),
(
  'LaunchedEffect restarts with wrong key parameters causing inefficiency or bugs',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Use specific state values that trigger effect as keys: LaunchedEffect(userId, username) not LaunchedEffect(true)", "percentage": 95, "note": "LaunchedEffect(true) is as suspicious as while(true) - always pause and verify necessity"},
    {"solution": "When callback changes, use rememberUpdatedState to prevent effect restart", "percentage": 90, "note": "Failing to use rememberUpdatedState causes effects to restart unnecessarily and disrupt long-lived operations"},
    {"solution": "Avoid suspicious constant keys - use stable, meaningful state values", "percentage": 85, "note": "Problems occur when effect restart parameters are not the right ones - causes either insufficient or excessive restarts"}
  ]'::jsonb,
  'Understanding Compose side-effects, Coroutine scope knowledge',
  'Effect runs expected number of times in debugger, No console warnings about suspicious effect keys, State-dependent operations complete as expected',
  'Using constant keys like LaunchedEffect(true) without considering effect frequency. Failing to capture updated callback values. Restarting less/more frequently than needed.',
  0.90,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/side-effects'
),
(
  'Jetpack Compose animation modifier placed after size modifier breaks animation',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Place animateContentSize() BEFORE size modifiers: Modifier.animateContentSize().size()", "percentage": 95, "note": "Modifier ordering is critical - wrong order prevents animation from working"},
    {"solution": "Use AnimatedVisibility instead of animateFloatAsState for visibility changes to properly remove from composition", "percentage": 92, "note": "animateFloatAsState keeps composable in composition, occupies layout space, confuses accessibility tools"},
    {"solution": "Use Modifier.graphicsLayer{} for draw-phase animations instead of layout-affecting changes", "percentage": 88, "note": "Layout-phase animations cause excessive recomposition - draw-phase is more efficient"}
  ]'::jsonb,
  'Compose animation API knowledge, Understanding Compose phases',
  'Animation executes smoothly in preview/emulator, Accessibility tools properly handle removed items, Recomposition count acceptable in profiler',
  'Placing animateContentSize after size modifiers. Using animateFloatAsState for visibility (keeps in composition). Animating layout-affecting properties causing recomposition.',
  0.91,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/animation/quick-guide'
),
(
  'DisposableEffect missing onDispose clause causes cleanup failures',
  'jetpack-compose',
  'MEDIUM',
  '[
    {"solution": "Always include onDispose clause as final statement in DisposableEffect: DisposableEffect { ... onDispose { cleanup() } }", "percentage": 98, "note": "IDE enforces this - build fails without onDispose. Required for proper resource cleanup on recomposition."},
    {"solution": "Use DisposableEffect for resources requiring cleanup: listeners, timers, subscriptions", "percentage": 95, "note": "For simple state changes, LaunchedEffect or remember suffice"},
    {"solution": "Ensure cleanup code properly removes listeners: removeListener(callback) with exact reference", "percentage": 90, "note": "Common mistake is using new lambda in cleanup that does not match registration lambda"}
  ]'::jsonb,
  'Understanding Compose lifecycle, Resource management knowledge',
  'No memory leaks in Android Studio Memory Profiler, Listeners properly removed on recomposition, IDE build succeeds without cleanup warnings',
  'Forgetting onDispose clause (IDE error). Creating new lambda in cleanup that does not match listener registration. Not cleaning up expensive resources properly.',
  0.96,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/side-effects'
),
(
  'Jetpack Compose state reading in wrong phase causes unnecessary recompositions or layout jank',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Defer state reads to layout phase using lambda: Modifier.offset { state.value } not Modifier.offset(state.value)", "percentage": 93, "note": "Lambda-based modifiers defer reads to layout phase, skipping composition phase entirely"},
    {"solution": "For frequently changing state during animation, use Modifier.graphicsLayer as draw-phase operation", "percentage": 91, "note": "Draw-phase reads do not trigger recomposition or layout - most efficient"},
    {"solution": "Use derivedStateOf when combining multiple state values to avoid excessive recompositions", "percentage": 88, "note": "Only use derivedStateOf for actual aggregation - wrapping simple state is overhead"}
  ]'::jsonb,
  'Understanding Compose phases (composition, layout, drawing), State management knowledge',
  'Smooth scrolling performance during animation without layout jank, Recomposition count low during state updates, 60 FPS maintained in profiler',
  'Reading state at composition phase when layout phase sufficient. Over-using derivedStateOf for simple state. Creating new modifier chains on every recomposition.',
  0.89,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/phases'
),
(
  'Jetpack Compose custom layout violates single-pass measurement causing unpredictable behavior',
  'jetpack-compose',
  'MEDIUM',
  '[
    {"solution": "Measure each child only once in custom layout: measure(child) called single time per layout phase", "percentage": 96, "note": "Compose UI forbids multi-pass measurement - violation causes undefined behavior or crashes"},
    {"solution": "Use placeRelative() for RTL-aware positioning, place() for absolute positioning", "percentage": 92, "note": "placeRelative respects text direction, place() ignores it - choose based on intent"},
    {"solution": "Follow three-step layout process: measure children, decide own size, place children in correct order", "percentage": 90, "note": "Breaking this order or re-measuring violates Compose constraints"}
  ]'::jsonb,
  'Custom Layout composable knowledge, Understanding Layout scope',
  'Custom layout compiles without errors, Measurements correct in layout preview, Text direction handled properly (RTL/LTR)',
  'Measuring child multiple times in custom layout. Using place() instead of placeRelative() for RTL. Deciding size before measuring children (wrong order).',
  0.93,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/layouts/custom'
),
(
  'Jetpack Compose side effects executing during composition instead of after render',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Never modify shared state, write files, or update ViewModels directly in composable body - move to callbacks", "percentage": 97, "note": "Composable functions may execute in any order, parallel, or be canceled - side effects unsafe"},
    {"solution": "Use LaunchedEffect for async operations and side effects that depend on composition", "percentage": 94, "note": "LaunchedEffect runs AFTER composition succeeds - safe for side effects"},
    {"solution": "Use callbacks (onClick, onValueChange) for user-triggered state updates", "percentage": 92, "note": "Keeps composable pure - only describes UI, does not mutate state"},
    {"solution": "Never track state changes within composable lambda (like incrementing counter) - causes thread-safety issues", "percentage": 89, "note": "Composables can re-execute at any time and in parallel - local mutations unsafe"}
  ]'::jsonb,
  'Understanding Compose mental model, Coroutine scope knowledge',
  'No shared state mutations in Logcat, Async operations complete properly, UI renders correctly without state corruption',
  'Writing to shared objects during composition. Modifying local variables within composable. Updating ViewModels directly in composable body. Expecting sequential execution.',
  0.94,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/mental-model'
),
(
  'Jetpack Compose test fails because semantics missing or incorrect',
  'jetpack-compose',
  'MEDIUM',
  '[
    {"solution": "Add semantics property with testTag: Modifier.semantics { testTagsAsResourceId = true }.testTag(\"myButton\")", "percentage": 94, "note": "Semantics give meaning to UI elements - required for tests to locate and interact with composables"},
    {"solution": "Use ComposeTestRule with setContent and verify with performClick/assertIsDisplayed", "percentage": 92, "note": "Standard test setup: androidTestImplementation(androidx.compose.ui:ui-test-junit4)"},
    {"solution": "Add debugImplementation(androidx.compose.ui:ui-test-manifest) for instrumented tests", "percentage": 90, "note": "Manifest dependency required for test infrastructure support"},
    {"solution": "Use onNodeWithTag/onNodeWithText for element lookup instead of relying on structure", "percentage": 88, "note": "Semantic-based lookup more robust than hierarchy-based"}
  ]'::jsonb,
  'Compose testing dependency configured, ComposeTestRule imported, Basic Kotlin test knowledge',
  'Test locates composable with onNodeWithTag, performClick() succeeds, Assertions pass with assertIsDisplayed()',
  'Missing testTag modifier on composable. Using only layout structure without semantics. Missing ui-test-manifest dependency. Assuming test infrastructure auto-discovered.',
  0.91,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/testing'
),
(
  'Jetpack Compose LaunchedEffect inside lazy layout restarts effect on scroll causing animations to replay',
  'jetpack-compose',
  'HIGH',
  '[
    {"solution": "Hoist LaunchedEffect outside lazy layout (LazyColumn/LazyRow) to stable scope", "percentage": 96, "note": "LaunchedEffect restarts when items re-enter composition during scroll - hoist state to parent"},
    {"solution": "Move animation trigger logic to parent composable where it runs once, not per item", "percentage": 93, "note": "Prevents animation replay for each list item on every recomposition"},
    {"solution": "For per-item effects, use explicit key parameter in LazyListScope.item() to preserve state", "percentage": 85, "note": "key ensures LaunchedEffect runs only once per unique item, not on each scroll"}
  ]'::jsonb,
  'Understanding lazy layout composition, State hoisting patterns',
  'Animation plays once regardless of scrolling, No animation replay when items re-enter viewport, Item state preserved across scroll',
  'Using LaunchedEffect directly inside lazy layout items without key. Expecting state to persist without key parameter. Triggering animation repeatedly on scroll.',
  0.92,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/animation/quick-guide'
),
(
  'Jetpack Compose recomposition loop from layout callback updating state',
  'jetpack-compose',
  'MEDIUM',
  '[
    {"solution": "Never call onSizeChanged { state.value = ... } directly - causes layout callback to update state that feeds to layout", "percentage": 97, "note": "Creates multi-frame cycle: layout -> callback -> state update -> recomposition -> layout again"},
    {"solution": "Use proper layout primitives (BoxWithConstraints, custom Layout) instead of size callbacks", "percentage": 94, "note": "These handle constraint propagation correctly without state loops"},
    {"solution": "If size-based logic needed, compute in separate state holder, not in layout modifier", "percentage": 89, "note": "Separates layout concerns from state management, breaks cycle"}
  ]'::jsonb,
  'Understanding Compose layout phases, State management knowledge',
  'Profiler shows single layout pass per frame, No multi-frame cycles, Performance smooth without jank',
  'Using onSizeChanged callback to update state that affects layout. Creating feedback loop between layout and composition. Expecting size changes to not trigger recomposition.',
  0.95,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/phases'
),
(
  'Jetpack Compose color animation performance degradation using Modifier.background',
  'jetpack-compose',
  'MEDIUM',
  '[
    {"solution": "Use drawBehind { } with animateColorAsState instead of Modifier.background() for animated colors", "percentage": 96, "note": "Modifier.background() causes excessive recomposition. drawBehind only affects drawing phase."},
    {"solution": "Hoist animated color state outside frequently-recomposing composable", "percentage": 92, "note": "Prevents color recalculation on every recomposition - isolate to separate state composable"},
    {"solution": "For simple color animations, use animateColorAsState which handles timing internally", "percentage": 89, "note": "Eliminates manual animation spec management, handles interruption gracefully"}
  ]'::jsonb,
  'Understanding Compose drawing phase, Animation API knowledge',
  'Smooth color animation at 60 FPS, Recomposition count low during animation, Android Profiler shows efficient rendering',
  'Using Modifier.background() with animateColorAsState for color changes. Updating color state at composition phase. Over-using color animation on every recomposition.',
  0.90,
  'sonnet-4',
  NOW(),
  'https://developer.android.com/develop/ui/compose/animation/quick-guide'
);
