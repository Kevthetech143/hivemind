-- React Common Errors - Batch 1
-- Mined from official React documentation (react.dev)
-- Focus: Hooks violations, state updates, useEffect issues, key warnings

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'React error: Hooks can only be called inside the body of a function component',
    'react',
    'VERY_HIGH',
    '[
        {"solution": "Move hook calls to the top level of your function component, not inside conditions, loops, or nested functions", "percentage": 95, "note": "Most common cause - violating Rules of Hooks"},
        {"solution": "Check for mismatching React and React DOM versions: npm ls react-dom (requires 16.8.0+)", "percentage": 85, "command": "npm ls react-dom"},
        {"solution": "Detect duplicate React copies in your dependency tree: npm ls react", "percentage": 80, "command": "npm ls react"},
        {"solution": "Install eslint-plugin-react-hooks to catch violations automatically", "percentage": 90, "command": "npm install eslint-plugin-react-hooks --save-dev"}
    ]'::jsonb,
    'React 16.8.0 or higher, Function component or custom hook context',
    'No error in console, Hooks execute successfully, Component renders properly',
    'Do not call hooks after conditional return statements. Do not call hooks in event handlers. Do not call hooks inside useMemo, useReducer, or useEffect callbacks. Hooks must be at top level only.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://react.dev/warnings/invalid-hook-call-warning'
),
(
    'React warning: Each child in a list should have a unique key prop',
    'react',
    'VERY_HIGH',
    '[
        {"solution": "Add a unique key prop from your data: items.map(item => <li key={item.id}>{item.name}</li>)", "percentage": 95, "note": "Use stable IDs from database when available"},
        {"solution": "For locally-generated data, use incrementing counter or uuid library, not Math.random()", "percentage": 90, "note": "Keys must remain consistent across re-renders"},
        {"solution": "Avoid using array index as key when items can be reordered, inserted, or deleted", "percentage": 85, "note": "Index-based keys cause subtle bugs with dynamic lists"}
    ]'::jsonb,
    'React application rendering arrays/lists, Unique identifier available in data',
    'Warning disappears from console, List updates correctly when items change order',
    'Never use Math.random() for keys - causes all components to recreate on every render. Array indices only work for static lists that never change. Keys are not passed as props to components.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://react.dev/learn/rendering-lists'
),
(
    'React useState: Screen does not update after calling setState',
    'react',
    'VERY_HIGH',
    '[
        {"solution": "Never mutate objects/arrays directly. Always create new copies: setObj({...obj, x: 10})", "percentage": 95, "note": "React uses Object.is comparison to detect changes"},
        {"solution": "For nested objects, spread at each level: setPerson({...person, artwork: {...person.artwork, city: value}})", "percentage": 90, "note": "Spread operator only copies one level deep"},
        {"solution": "For complex nested state, use Immer library to handle immutability automatically", "percentage": 85, "command": "npm install use-immer"}
    ]'::jsonb,
    'React component using useState hook, Object or array state',
    'Component re-renders when state changes, UI reflects updated values',
    'Mutating state directly (obj.x = 10; setObj(obj)) prevents React from detecting changes. Always replace rather than mutate. Spread syntax is shallow - nested properties need manual spreading.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useState'
),
(
    'React error: Too many re-renders',
    'react',
    'VERY_HIGH',
    '[
        {"solution": "Pass function reference to onClick, not function call: <button onClick={handleClick}> not onClick={handleClick()}", "percentage": 95, "note": "Most common cause - calling event handler during render"},
        {"solution": "Check for setState calls during render phase - move to useEffect or event handlers", "percentage": 90, "note": "Setting state during render creates infinite loop"},
        {"solution": "Use useEffect dependency array correctly to prevent unnecessary re-runs", "percentage": 85, "note": "Missing or incorrect dependencies cause loops"}
    ]'::jsonb,
    'React component with event handlers or effects',
    'Component renders normally without infinite loop, Console shows no errors',
    'Event handlers should be passed as references (onClick={fn}), not called during render (onClick={fn()}). Never call setState in the render body - use effects or event handlers only.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useState'
),
(
    'React useState: Multiple setState calls only apply the last value',
    'react',
    'HIGH',
    '[
        {"solution": "Use updater function form when setting state multiple times: setAge(a => a + 1)", "percentage": 95, "note": "Queues updates based on previous state"},
        {"solution": "Each updater receives the pending state from previous updater: setAge(a => a + 1); setAge(a => a + 1)", "percentage": 90, "note": "All updates apply in sequence"}
    ]'::jsonb,
    'React component using useState, Multiple state updates in single event handler',
    'All state updates apply correctly, Final value reflects all changes',
    'Calling setAge(age + 1) multiple times uses the same age value. Must use updater function setAge(a => a + 1) to queue based on previous state.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useState'
),
(
    'React useState: Getting old state value immediately after setState',
    'react',
    'HIGH',
    '[
        {"solution": "Save next state in variable before passing to setter if you need immediate value: const nextCount = count + 1; setCount(nextCount); console.log(nextCount)", "percentage": 90, "note": "State updates only apply on next render"},
        {"solution": "Use useEffect to react to state changes: useEffect(() => { console.log(count); }, [count])", "percentage": 85, "note": "Runs after state has updated"}
    ]'::jsonb,
    'React component using useState hook',
    'Code correctly handles current vs next state values',
    'State updates are batched and only applied for next render. Reading state immediately after calling setter returns the OLD value. This is expected React behavior, not a bug.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useState'
),
(
    'React useEffect: Infinite loop - Effect runs on every render',
    'react',
    'VERY_HIGH',
    '[
        {"solution": "Add dependency array to useEffect: useEffect(() => {...}, [dep1, dep2])", "percentage": 95, "note": "Empty array runs once, specific deps run when they change"},
        {"solution": "Move object/function creation inside Effect or use useMemo/useCallback to stabilize references", "percentage": 90, "note": "Objects created during render are new on every render"},
        {"solution": "For state updates, use updater form to remove state from dependencies: setCount(c => c + 1)", "percentage": 88, "note": "Prevents dependency on current state value"}
    ]'::jsonb,
    'React component using useEffect hook',
    'Effect runs only when dependencies actually change, No infinite loop',
    'Objects and functions created during rendering cause new references each render. Effect updates state which triggers re-render which creates new dependencies. Use dependency array correctly.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useEffect'
),
(
    'React useEffect: Missing dependencies warning from ESLint',
    'react',
    'HIGH',
    '[
        {"solution": "Add all reactive values used in Effect to dependency array", "percentage": 95, "note": "Every reactive value must be declared as dependency"},
        {"solution": "Move non-reactive code outside Effect or wrap in useMemo/useCallback", "percentage": 85, "note": "Reduces number of required dependencies"},
        {"solution": "Use ESLint plugin eslint-plugin-react-hooks with exhaustive-deps rule enabled", "percentage": 90, "command": "npm install eslint-plugin-react-hooks --save-dev"}
    ]'::jsonb,
    'React component with useEffect, eslint-plugin-react-hooks installed',
    'ESLint warning disappears, Effect has complete dependency list',
    'Ignoring the linter and omitting dependencies causes stale closure bugs. Every prop, state, or variable from component scope used inside Effect must be in dependency array.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useEffect'
),
(
    'React useEffect: Cleanup function runs on every re-render, not just unmount',
    'react',
    'MEDIUM',
    '[
        {"solution": "This is expected behavior - cleanup runs before every Effect re-run with changed dependencies", "percentage": 95, "note": "Not a bug, cleanup mirrors setup on each run"},
        {"solution": "Ensure cleanup properly undoes setup: if setup creates connection, cleanup must close it", "percentage": 90, "note": "Cleanup should mirror setup logic exactly"},
        {"solution": "In Strict Mode dev environment, React runs setup→cleanup→setup to test cleanup logic", "percentage": 85, "note": "Double execution only happens in development"}
    ]'::jsonb,
    'React component with useEffect cleanup function',
    'Cleanup properly undoes setup, No memory leaks, No duplicate subscriptions',
    'Cleanup does not only run on unmount - it runs before every re-run when dependencies change. If you see issues during development double-execution, your cleanup needs additional logic.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/useEffect'
),
(
    'React component mutation: Modifying props or external variables during render',
    'react',
    'HIGH',
    '[
        {"solution": "Never mutate props: create new array instead of pushing to prop array", "percentage": 95, "note": "Mutations break React purity contract"},
        {"solution": "Move side effects (DOM manipulation, API calls) to event handlers or useEffect", "percentage": 93, "note": "Rendering should only calculate and return JSX"},
        {"solution": "Use local variables for mutations within render, not external/shared state", "percentage": 90, "note": "Local mutations inside component are safe"}
    ]'::jsonb,
    'React component, Strict Mode enabled (detects impurity)',
    'Component produces same output for same inputs, No side effects during render',
    'Modifying external variables or props during render violates purity - same inputs must produce same output. Use useState for changing values. Strict Mode calls components twice to surface these issues.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://react.dev/learn/keeping-components-pure'
),
(
    'React anti-pattern: Using useEffect for calculations that could happen during render',
    'react',
    'HIGH',
    '[
        {"solution": "Calculate derived values directly during rendering, not in Effects: const fullName = firstName + lastName", "percentage": 95, "note": "No need to store in state or update in Effect"},
        {"solution": "Use useMemo only for expensive calculations: const filtered = useMemo(() => list.filter(fn), [list])", "percentage": 90, "note": "Most calculations are fast enough without memoization"},
        {"solution": "Handle user events directly in event handlers, not Effects watching state", "percentage": 93, "note": "Effects dont know what triggered them - event handlers have context"}
    ]'::jsonb,
    'React component with unnecessary useEffect',
    'Code is simpler, Fewer re-renders, Derived values calculate correctly',
    'Creating state for derived values and updating in Effects causes unnecessary renders. Calculate during render instead. Effects are for synchronizing with external systems, not transforming data.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://react.dev/learn/you-might-not-need-an-effect'
),
(
    'React class component: setState does not update state immediately',
    'react',
    'MEDIUM',
    '[
        {"solution": "Access updated state in componentDidUpdate, not immediately after setState call", "percentage": 90, "note": "setState is asynchronous - queues update for next render"},
        {"solution": "Use callback parameter if you need to act on updated state: this.setState({count: 1}, () => console.log(this.state.count))", "percentage": 85, "note": "Callback runs after state updates"},
        {"solution": "For state updates based on previous state, use updater function: this.setState(prevState => ({count: prevState.count + 1}))", "percentage": 88, "note": "Prevents stale state bugs"}
    ]'::jsonb,
    'React class component using this.setState',
    'State updates correctly in next render, Code handles async nature of setState',
    'Calling setState does NOT change current state in already executing code. State update is queued. Reading this.state immediately after setState returns old value. Use updater function form for state-based updates.',
    0.89,
    'sonnet-4',
    NOW(),
    'https://react.dev/reference/react/Component'
);
