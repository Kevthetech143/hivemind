INSERT INTO knowledge_entries (query, category, type, solutions, executable_type, prerequisites, common_pitfalls, success_indicators, preview_summary, source_url, contributor_email)
VALUES (
  'web3-testing - Test smart contracts comprehensively using Hardhat and Foundry with unit tests, integration tests, and mainnet forking',
  'claude-code',
  'skill',
  '[
    {"solution": "Set up Hardhat testing environment", "cli": {"macos": "npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomiclabs/hardhat-etherscan hardhat-gas-reporter solidity-coverage", "linux": "npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomiclabs/hardhat-etherscan hardhat-gas-reporter solidity-coverage", "windows": "npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @nomiclabs/hardhat-etherscan hardhat-gas-reporter solidity-coverage"}, "manual": "Install Hardhat dev dependencies including toolbox, Etherscan integration, gas reporting, and coverage tools. Create hardhat.config.js with network and compiler settings", "note": "Include mainnet forking URL in hardhat config for realistic testing"},
    {"solution": "Write basic unit tests with Hardhat", "cli": {"macos": "cat > test/Token.test.js << ''TEST''\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { loadFixture } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe(\"Token\", function () {\n  async function deployTokenFixture() {\n    const [owner, addr1] = await ethers.getSigners();\n    const Token = await ethers.getContractFactory(\"Token\");\n    const token = await Token.deploy();\n    return { token, owner, addr1 };\n  }\n\n  it(\"Should have correct owner\", async function () {\n    const { token, owner } = await loadFixture(deployTokenFixture);\n    expect(await token.owner()).to.equal(owner.address);\n  });\n\n  it(\"Should transfer tokens\", async function () {\n    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n    await expect(token.transfer(addr1.address, 100))\n      .to.changeTokenBalances(token, [owner, addr1], [-100, 100]);\n  });\n});\nTEST", "linux": "cat > test/Token.test.js << ''TEST''\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { loadFixture } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe(\"Token\", function () {\n  async function deployTokenFixture() {\n    const [owner, addr1] = await ethers.getSigners();\n    const Token = await ethers.getContractFactory(\"Token\");\n    const token = await Token.deploy();\n    return { token, owner, addr1 };\n  }\n\n  it(\"Should have correct owner\", async function () {\n    const { token, owner } = await loadFixture(deployTokenFixture);\n    expect(await token.owner()).to.equal(owner.address);\n  });\n\n  it(\"Should transfer tokens\", async function () {\n    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n    await expect(token.transfer(addr1.address, 100))\n      .to.changeTokenBalances(token, [owner, addr1], [-100, 100]);\n  });\n});\nTEST", "windows": "cat > test/Token.test.js << ''TEST''\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { loadFixture } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe(\"Token\", function () {\n  async function deployTokenFixture() {\n    const [owner, addr1] = await ethers.getSigners();\n    const Token = await ethers.getContractFactory(\"Token\");\n    const token = await Token.deploy();\n    return { token, owner, addr1 };\n  }\n\n  it(\"Should have correct owner\", async function () {\n    const { token, owner } = await loadFixture(deployTokenFixture);\n    expect(await token.owner()).to.equal(owner.address);\n  });\n\n  it(\"Should transfer tokens\", async function () {\n    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n    await expect(token.transfer(addr1.address, 100))\n      .to.changeTokenBalances(token, [owner, addr1], [-100, 100]);\n  });\n});\nTEST"}, "manual": "Create test files using Chai assertions and Hardhat fixtures. Use loadFixture for reusable setup. Test token transfers, balance changes, and event emissions", "note": "Use changeTokenBalances matcher for clean token balance testing"},
    {"solution": "Test event emissions and error handling", "cli": {"macos": "cat > test/Events.test.js << ''EVENTS''\nit(\"Should emit Transfer event\", async function () {\n  const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(token.transfer(addr1.address, 50))\n    .to.emit(token, \"Transfer\")\n    .withArgs(owner.address, addr1.address, 50);\n});\n\nit(\"Should revert with insufficient balance\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).transfer(owner.address, 1)\n  ).to.be.revertedWith(\"Insufficient balance\");\n});\nEVENTS", "linux": "cat > test/Events.test.js << ''EVENTS''\nit(\"Should emit Transfer event\", async function () {\n  const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(token.transfer(addr1.address, 50))\n    .to.emit(token, \"Transfer\")\n    .withArgs(owner.address, addr1.address, 50);\n});\n\nit(\"Should revert with insufficient balance\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).transfer(owner.address, 1)\n  ).to.be.revertedWith(\"Insufficient balance\");\n});\nEVENTS", "windows": "cat > test/Events.test.js << ''EVENTS''\nit(\"Should emit Transfer event\", async function () {\n  const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(token.transfer(addr1.address, 50))\n    .to.emit(token, \"Transfer\")\n    .withArgs(owner.address, addr1.address, 50);\n});\n\nit(\"Should revert with insufficient balance\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).transfer(owner.address, 1)\n  ).to.be.revertedWith(\"Insufficient balance\");\n});\nEVENTS"}, "manual": "Test event emissions using .to.emit() matcher with .withArgs(). Test error cases using .to.be.revertedWith(). Verify both happy path and failure scenarios", "note": "Always test both success and failure cases for complete coverage"},
    {"solution": "Set up Foundry for Solidity-native testing", "cli": {"macos": "curl -L https://foundry.paradigm.xyz | bash && ~/.foundry/bin/foundryup", "linux": "curl -L https://foundry.paradigm.xyz | bash && ~/.foundry/bin/foundryup", "windows": "powershell -Command \"(irm https://raw.githubusercontent.com/foundry-rs/foundry/master/foundryup/install.ps1) | iex\""}, "manual": "Install Foundry toolchain which includes Forge (testing), Cast (debugging), and Anvil (local node). Create foundry.toml config file in project root", "note": "Foundry tests run in Solidity, not JavaScript - useful for testing gas-heavy operations"},
    {"solution": "Write Foundry unit tests with Solidity", "cli": {"macos": "cat > test/Token.t.sol << ''FTEST''\npragma solidity ^0.8.0;\nimport \"forge-std/Test.sol\";\nimport \"../src/Token.sol\";\n\ncontract TokenTest is Test {\n    Token token;\n    address owner = address(1);\n\n    function setUp() public {\n        vm.prank(owner);\n        token = new Token();\n    }\n\n    function testTransfer() public {\n        vm.prank(owner);\n        token.transfer(address(2), 100);\n        assertEq(token.balanceOf(address(2)), 100);\n    }\n\n    function testFuzzTransfer(uint256 amount) public {\n        vm.assume(amount > 0 && amount <= token.totalSupply());\n        vm.prank(owner);\n        token.transfer(address(2), amount);\n        assertEq(token.balanceOf(address(2)), amount);\n    }\n}\nFTEST", "linux": "cat > test/Token.t.sol << ''FTEST''\npragma solidity ^0.8.0;\nimport \"forge-std/Test.sol\";\nimport \"../src/Token.sol\";\n\ncontract TokenTest is Test {\n    Token token;\n    address owner = address(1);\n\n    function setUp() public {\n        vm.prank(owner);\n        token = new Token();\n    }\n\n    function testTransfer() public {\n        vm.prank(owner);\n        token.transfer(address(2), 100);\n        assertEq(token.balanceOf(address(2)), 100);\n    }\n\n    function testFuzzTransfer(uint256 amount) public {\n        vm.assume(amount > 0 && amount <= token.totalSupply());\n        vm.prank(owner);\n        token.transfer(address(2), amount);\n        assertEq(token.balanceOf(address(2)), amount);\n    }\n}\nFTEST", "windows": "cat > test/Token.t.sol << ''FTEST''\npragma solidity ^0.8.0;\nimport \"forge-std/Test.sol\";\nimport \"../src/Token.sol\";\n\ncontract TokenTest is Test {\n    Token token;\n    address owner = address(1);\n\n    function setUp() public {\n        vm.prank(owner);\n        token = new Token();\n    }\n\n    function testTransfer() public {\n        vm.prank(owner);\n        token.transfer(address(2), 100);\n        assertEq(token.balanceOf(address(2)), 100);\n    }\n\n    function testFuzzTransfer(uint256 amount) public {\n        vm.assume(amount > 0 && amount <= token.totalSupply());\n        vm.prank(owner);\n        token.transfer(address(2), amount);\n        assertEq(token.balanceOf(address(2)), amount);\n    }\n}\nFTEST"}, "manual": "Write test files in Solidity (.t.sol extension). Use vm cheatcodes for impersonation (vm.prank), time manipulation, deal for ETH. Use testFuzz prefix for property-based fuzzing tests", "note": "Foundry can fuzz test with vm.assume() to filter inputs. Runs much faster than Hardhat JS tests"},
    {"solution": "Fork mainnet for realistic testing", "cli": {"macos": "npx hardhat test --network hardhat --grep \"Fork\" || forge test --fork-url https://eth-mainnet.alchemyapi.io/v2/YOUR_KEY", "linux": "npx hardhat test --network hardhat --grep \"Fork\" || forge test --fork-url https://eth-mainnet.alchemyapi.io/v2/YOUR_KEY", "windows": "npx hardhat test --network hardhat --grep \"Fork\" || forge test --fork-url https://eth-mainnet.alchemyapi.io/v2/YOUR_KEY"}, "manual": "Configure hardhat.config.js with forking: { jsonRpcUrl, blockNumber }. Or run Foundry with --fork-url flag. Interact with real mainnet contracts in tests without spending gas", "note": "Pin block number for reproducible tests. Impersonate whale accounts with vm.prank()"},
    {"solution": "Test gas optimization and efficiency", "cli": {"macos": "npx hardhat test --grep \"Gas\" && npx hardhat coverage", "linux": "npx hardhat test --grep \"Gas\" && npx hardhat coverage", "windows": "npx hardhat test --grep \"Gas\" && npx hardhat coverage"}, "manual": "Write tests that measure gas usage: const receipt = await tx.wait(); expect(receipt.gasUsed).to.be.lessThan(50000). Run coverage with npx hardhat coverage to identify untested code", "note": "Aim for >90% coverage. Gas reporter shows costs per function"},
    {"solution": "Impersonate accounts and test access control", "cli": {"macos": "cat > test/AccessControl.test.js << ''ACCESS''\nit(\"Should prevent unauthorized access\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).mint(addr1.address, 1000)\n  ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n});\n\nit(\"Should impersonate whale\", async function () {\n  const whale = \"0x...\";\n  await network.provider.request({\n    method: \"hardhat_impersonateAccount\",\n    params: [whale]\n  });\n  const whaleSigner = await ethers.getSigner(whale);\n  // Use whale to test\n});\nACCESS", "linux": "cat > test/AccessControl.test.js << ''ACCESS''\nit(\"Should prevent unauthorized access\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).mint(addr1.address, 1000)\n  ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n});\n\nit(\"Should impersonate whale\", async function () {\n  const whale = \"0x...\";\n  await network.provider.request({\n    method: \"hardhat_impersonateAccount\",\n    params: [whale]\n  });\n  const whaleSigner = await ethers.getSigner(whale);\n  // Use whale to test\n});\nACCESS", "windows": "cat > test/AccessControl.test.js << ''ACCESS''\nit(\"Should prevent unauthorized access\", async function () {\n  const { token, addr1 } = await loadFixture(deployTokenFixture);\n  await expect(\n    token.connect(addr1).mint(addr1.address, 1000)\n  ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n});\n\nit(\"Should impersonate whale\", async function () {\n  const whale = \"0x...\";\n  await network.provider.request({\n    method: \"hardhat_impersonateAccount\",\n    params: [whale]\n  });\n  const whaleSigner = await ethers.getSigner(whale);\n  // Use whale to test\n});\nACCESS"}, "manual": "Test access control by connecting as different signers: token.connect(addr1). Test reentrancy, authorization checks. Use vm.prank() in Foundry or hardhat_impersonateAccount for mainnet accounts", "note": "Test both positive cases (authorized) and negative cases (unauthorized)"},
    {"solution": "Set up CI/CD for automated testing", "cli": {"macos": "cat > .github/workflows/test.yml << ''CI''\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm install\n      - run: npx hardhat test\n      - run: npx hardhat coverage\n      - uses: codecov/codecov-action@v3\nCI", "linux": "cat > .github/workflows/test.yml << ''CI''\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm install\n      - run: npx hardhat test\n      - run: npx hardhat coverage\n      - uses: codecov/codecov-action@v3\nCI", "windows": "cat > .github/workflows/test.yml << ''CI''\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm install\n      - run: npx hardhat test\n      - run: npx hardhat coverage\n      - uses: codecov/codecov-action@v3\nCI"}, "manual": "Create .github/workflows/test.yml to run tests on every push/PR. Steps: checkout, setup Node, install deps, compile, test, generate coverage. Upload to Codecov for tracking", "note": "Fast feedback loop on PRs. Prevents regressions before merge"}
  ]'::jsonb,
  'script',
  'Solidity knowledge; Node.js/npm; Hardhat or Foundry installed; Ethereum RPC endpoint; ERC20 understanding',
  'Not testing revert conditions; Missing access control tests; Insufficient gas measurements; Not testing events; Ignoring edge cases in fuzzing; Forgetting to impersonate in mainnet fork; Low coverage (<80%)',
  'Tests compile and run; All assertions pass; Gas reports generated; Coverage >90%; Events verified; Access control tested; Mainnet fork works; CI/CD executes successfully',
  'Comprehensive smart contract testing using Hardhat/Foundry. Unit tests, fuzzing, mainnet forking, gas optimization, event verification, access control testing, and CI/CD automation.',
  'https://skillsmp.com/skills/wshobson-agents-plugins-blockchain-web3-skills-web3-testing-skill-md',
  'admin:HAIKU_SKILL_1764289684_93067'
);
