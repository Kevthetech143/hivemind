-- PostgreSQL Error Codes - Official Docs Mining
-- Source: postgresql.org/docs/current/errcodes-appendix.html
-- Mined: 2025-11-25

INSERT INTO knowledge_entries (
    query, category, hit_frequency, solutions, prerequisites, success_indicators,
    common_pitfalls, success_rate, claude_version, last_verified, source_url
) VALUES (
    'PostgreSQL error: 08006 - connection_failure - Connection dropped unexpectedly',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Check database server status with pg_isready. Verify network connectivity. Check PostgreSQL logs in pg_log/. Review connection timeout settings in postgresql.conf. Restart PostgreSQL service if needed: sudo systemctl restart postgresql", "percentage": 85, "note": "Most common cause is network interruption or server crash"}, {"solution": "Increase tcp_keepalives_idle and tcp_keepalives_interval in postgresql.conf to prevent idle connection drops", "percentage": 70, "note": "For long-running connections"}]$$::jsonb,
    'PostgreSQL server installed and running. Network connectivity between client and server. Access to postgresql.conf configuration file.',
    'Connection re-establishes without errors. pg_isready returns accepting connections. Application can execute queries without connection_failure',
    'Confusing connection_failure with authentication errors. Not checking server logs first. Forgetting to reload config after postgresql.conf changes. Not checking firewall rules.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 23502 - not_null_violation - NULL inserted in NOT NULL column',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Identify which column caused the violation in the error message. Check your INSERT or UPDATE statement for columns not providing values. Add DEFAULT clause to schema or provide explicit values in DML. Example: ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT ''value''", "percentage": 95, "note": "Most straightforward fix"}, {"solution": "Review application code inserting NULL values. Validate input data before insertion. Add NOT NULL constraints only to columns that should never be null", "percentage": 90, "note": "Preventive approach"}]$$::jsonb,
    'Database access with ALTER TABLE or DML privileges. Understanding of NOT NULL constraints. Access to application code performing inserts.',
    'INSERT/UPDATE statements complete without not_null_violation errors. All rows inserted with proper values. Schema allows nullable columns where appropriate.',
    'Adding NOT NULL constraints too broadly. Not checking default values. Assuming framework handles NULL protection automatically. Not validating input before database operations.',
    0.95,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 23503 - foreign_key_violation - Foreign key constraint broken',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Identify the foreign key constraint from error message. Verify referenced parent record exists: SELECT * FROM parent_table WHERE id = value. Insert parent record first before child record. Use DEFERRABLE INITIALLY DEFERRED if dealing with circular dependencies", "percentage": 92, "note": "Standard approach"}, {"solution": "Temporarily disable constraint with ALTER TABLE child_table DISABLE TRIGGER ALL, perform operation, then re-enable. Use only for data migration scenarios", "percentage": 60, "note": "Last resort - risky approach"}]$$::jsonb,
    'Database access. Understanding of foreign key relationships. Parent table accessible. DML privileges.',
    'INSERT/UPDATE/DELETE operations succeed. Foreign key constraint maintained. Referential integrity intact. SELECT on parent table returns expected records.',
    'Forgetting to insert parent records first. Deleting parent without checking child references. Disabling constraints without re-enabling. Not understanding cascade vs restrict options.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 23505 - unique_violation - Duplicate value in unique constraint',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Check for existing duplicate: SELECT * FROM table_name WHERE column_name = ''value''. Either use different value or update existing record instead of inserting. Use INSERT ... ON CONFLICT DO UPDATE for upsert pattern", "percentage": 96, "note": "Most common solution"}, {"solution": "If migration/import issue, exclude duplicates: INSERT INTO table SELECT DISTINCT * FROM import_table WHERE NOT EXISTS (SELECT 1 FROM table WHERE id = import_table.id)", "percentage": 85, "note": "For bulk operations"}]$$::jsonb,
    'Database access with SELECT/INSERT privileges. Understanding of unique constraints. Access to table schema.',
    'INSERT/UPDATE completes without unique_violation. Duplicate check queries return expected results. Upsert operations work correctly.',
    'Not checking for duplicates before insert. Using INSERT instead of INSERT ON CONFLICT. Deleting constraint instead of fixing data. Not handling NULL uniqueness correctly.',
    0.96,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 23514 - check_violation - CHECK constraint failed',
    'postgresql',
    'HIGH',
    $$[{"solution": "Review CHECK constraint definition: SELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conname = ''constraint_name''. Verify inserted/updated values satisfy condition. Modify data to meet constraint or ALTER TABLE to change constraint definition", "percentage": 93, "note": "Standard fix"}, {"solution": "Examine constraint logic: SELECT constraint_name, constraint_definition FROM information_schema.table_constraints WHERE table_name = ''table_name'' AND constraint_type = ''CHECK''", "percentage": 88, "note": "To understand requirement"}]$$::jsonb,
    'Database access with ALTER TABLE privileges. Understanding of CHECK constraint syntax. Table schema knowledge.',
    'INSERT/UPDATE operations succeed. Data meets all CHECK constraint conditions. Queries confirm data integrity.',
    'Not reading constraint definition carefully. Using invalid data types. Forgetting about existing data when adding constraints. Not considering edge cases.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 42601 - syntax_error - Invalid SQL syntax',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Enable query logging: ALTER SYSTEM SET log_statement = ''all''. Restart PostgreSQL. Check error message for exact character position. Review SQL for: unclosed quotes, missing commas, invalid keywords, mismatched parentheses, schema.table notation errors", "percentage": 97, "note": "Direct approach"}, {"solution": "Use PostgreSQL query validator: EXPLAIN ANALYZE query_statement. Test simple SELECT first, then build complexity. Use IDE with SQL syntax highlighting and validation", "percentage": 88, "note": "Preventive approach"}]$$::jsonb,
    'PostgreSQL server access. SQL query to validate. Basic SQL knowledge.',
    'Query executes without syntax_error. EXPLAIN ANALYZE returns plan. Syntax highlighting shows no errors. Application compiles/runs successfully.',
    'Copy-pasting malformed SQL. Mixing SQL dialects. Not escaping special characters. Missing table/schema prefixes. Using reserved keywords without quoting.',
    0.97,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 42703 - undefined_column - Column does not exist',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Verify column name with: SELECT column_name FROM information_schema.columns WHERE table_name = ''table_name''. Check for typos, case sensitivity (PostgreSQL folds unquoted names to lowercase), schema prefix. Quote column if it contains special chars: SELECT \"Column\" FROM table", "percentage": 98, "note": "Always verify spelling first"}, {"solution": "If using alias: SELECT col AS alias FROM table. Then reference must use qualified name in WHERE, not alias. Use alias only in ORDER BY or GROUP BY", "percentage": 85, "note": "Common with aliases"}]$$::jsonb,
    'Database access. Table exists. SELECT privileges.',
    'Query executes without undefined_column error. Column queries return expected metadata. Application selects correct columns.',
    'Case sensitivity assumptions (PostgreSQL lowercases unquoted names). Not using schema prefix for ambiguous columns. Referencing aliases in WHERE clause. Typos in column names.',
    0.98,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 42P01 - undefined_table - Table does not exist',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Verify table exists: SELECT table_name FROM information_schema.tables WHERE table_name = ''table_name''. Check schema: SELECT table_schema FROM information_schema.tables WHERE table_name = ''table_name''. Use full qualified name: schema.table_name. Check for typos and case (unquoted names lowercase)", "percentage": 98, "note": "Straightforward diagnosis"}, {"solution": "Check if table in different schema: SET search_path = schema1, schema2, public; or qualify query: SELECT * FROM other_schema.table_name", "percentage": 90, "note": "When table exists but in different schema"}]$$::jsonb,
    'Database access. SELECT privileges on information_schema.',
    'Table metadata queries return results. Query executes without undefined_table error. Proper schema qualification used.',
    'Wrong schema context. Typos in table names. Not using quoted identifiers for case-sensitive names. Assuming table created in wrong schema.',
    0.98,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 42883 - undefined_function - Function not found',
    'postgresql',
    'HIGH',
    $$[{"solution": "Check function exists: SELECT proname FROM pg_proc WHERE proname = ''function_name''. Verify argument types match. Use full signature: function_name(arg_type1, arg_type2). Check schema: CREATE SCHEMA IF NOT EXISTS; CREATE FUNCTION schema.function_name()", "percentage": 94, "note": "Function overloading requires exact type match"}, {"solution": "List available functions: SELECT proname, pg_get_functiondef(oid) FROM pg_proc WHERE proname LIKE ''pattern%''. Check if extension needs installation: CREATE EXTENSION IF NOT EXISTS extension_name", "percentage": 88, "note": "Discovery and extension approach"}]$$::jsonb,
    'Database access. Function creation or extension privileges. Understanding of function signatures and overloading.',
    'Function calls execute successfully. pg_proc queries return expected results. Extensions loaded if needed.',
    'Incorrect argument types or count. Case sensitivity in function names. Not installing required extensions. Function in wrong schema. Typos in function names.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 42501 - insufficient_privilege - Missing permissions',
    'postgresql',
    'HIGH',
    $$[{"solution": "Grant required privilege: GRANT SELECT ON table_name TO role_name; or GRANT ALL PRIVILEGES ON table_name TO role_name;. For schemas: GRANT USAGE ON SCHEMA schema_name TO role_name;. For sequence: GRANT USAGE ON SEQUENCE seq_name TO role_name;", "percentage": 93, "note": "Standard grant approach"}, {"solution": "Check current privileges: SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE table_name = ''table_name''. Login as superuser to verify: sudo -u postgres psql", "percentage": 89, "note": "Verification approach"}]$$::jsonb,
    'PostgreSQL superuser access or GRANT privilege. Understanding of role-based access. Table/schema to grant on.',
    'GRANT statements execute successfully. Query runs without insufficient_privilege error. Role has required permissions verified with information_schema.',
    'Granting to wrong role. Not granting on all related objects (table + sequences). Forgetting schema USAGE privilege. Not checking default privileges.',
    0.93,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 40001 - serialization_failure - Concurrent transaction conflict',
    'postgresql',
    'MEDIUM',
    $$[{"solution": "Implement transaction retry logic with exponential backoff. Wrap in try-catch and retry up to 3 times. Reduce transaction duration by simplifying queries. Use READ COMMITTED isolation level if appropriate: SET TRANSACTION ISOLATION LEVEL READ COMMITTED;", "percentage": 88, "note": "Application-level solution"}, {"solution": "Analyze conflict source with pg_stat_statements. Consider using advisory locks: SELECT pg_advisory_lock(1); for critical sections. Increase work_mem for complex queries", "percentage": 75, "note": "Database tuning approach"}]$$::jsonb,
    'Application code with transaction handling. Understanding of isolation levels. Access to query analysis tools.',
    'Transaction retries succeed within 2-3 attempts. Serialization_failure errors rare. Application performance acceptable. No deadlock waits.',
    'No retry logic implemented. Not reducing transaction scope. Using SERIALIZABLE with high concurrency. Not logging retry attempts. Infinite retry loops.',
    0.88,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 40P01 - deadlock_detected - Circular lock dependency',
    'postgresql',
    'MEDIUM',
    $$[{"solution": "Analyze deadlock from logs (log_min_error_statement = all). Access deadlock info in PostgreSQL logs. Restructure queries to acquire locks in consistent order. Move from UPDATE then INSERT to INSERT then UPDATE. Add NOWAIT clause to prevent blocking: SELECT ... FOR UPDATE NOWAIT;", "percentage": 90, "note": "Root cause approach"}, {"solution": "Implement retry logic at application level. Implement queue-based processing instead of concurrent updates. Use lower isolation level if safe: SET TRANSACTION ISOLATION LEVEL READ COMMITTED;", "percentage": 82, "note": "Architecture change approach"}]$$::jsonb,
    'Database with deadlock logging enabled. Application-level transaction handling. Log file access. Understanding of lock ordering.',
    'Deadlock_detected errors eliminate or rare. Transactions complete successfully. Log analysis shows no new deadlocks. Application performance restored.',
    'Assuming deadlock is database bug. Ignoring lock order consistency. Holding locks too long. Not logging deadlock details. Changing isolation level blindly.',
    0.90,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 53200 - out_of_memory - Insufficient RAM',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Check current memory usage: SHOW work_mem; SHOW shared_buffers; Reduce work_mem for sorting/hashing: ALTER SYSTEM SET work_mem = ''256MB''; Lower shared_buffers if too high. Restart PostgreSQL. Run VACUUM ANALYZE to free space", "percentage": 85, "note": "Configuration tuning"}, {"solution": "Optimize queries: Add indexes on WHERE/JOIN columns. Use LIMIT for large result sets. Break large operations into smaller batches. Kill long-running queries: SELECT pg_terminate_backend(pid) FROM pg_stat_activity;", "percentage": 82, "note": "Query optimization approach"}]$$::jsonb,
    'PostgreSQL superuser access. Server with sufficient available RAM. Query access to pg_stat_activity.',
    'Queries execute without out_of_memory error. Memory usage stable below threshold. pg_stat_activity shows no stuck processes.',
    'Setting work_mem too high globally. Not VACUUM ANALYZE before major operations. Running huge queries without batching. Not monitoring memory before crisis.',
    0.85,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 53100 - disk_full - Storage capacity exhausted',
    'postgresql',
    'CRITICAL',
    $$[{"solution": "Identify large objects: SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||''.''||tablename)) FROM pg_tables ORDER BY pg_total_relation_size DESC LIMIT 10; Delete old data: DELETE FROM logs WHERE created_at < NOW() - INTERVAL ''90 days'';. VACUUM ANALYZE to reclaim space", "percentage": 94, "note": "Data cleanup approach"}, {"solution": "Expand disk: Check partition: df -h. Add disk space to server. Increase PostgreSQL tablespace size. Monitor with: SELECT pg_database_size(current_database()); before/after", "percentage": 85, "note": "Infrastructure expansion"}]$$::jsonb,
    'PostgreSQL superuser access. Disk access or cloud storage management. Query access to pg_tables and pg_size metrics.',
    'Disk space becomes available (df -h shows increase). Queries execute without disk_full error. Database operations complete successfully.',
    'Deleting wrong data. Not backing up before cleanup. Ignoring warning space levels. Not monitoring disk proactively. Expanding but not vacuuming.',
    0.94,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 53300 - too_many_connections - Connection limit exceeded',
    'postgresql',
    'HIGH',
    $$[{"solution": "Check connection limit: SHOW max_connections; Check active: SELECT count(*) FROM pg_stat_activity;. Increase limit: ALTER SYSTEM SET max_connections = 400; then RELOAD config. Kill idle: SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = ''idle'';", "percentage": 91, "note": "Direct fix approach"}, {"solution": "Implement connection pooling (PgBouncer, pgPool). Set application pool size correctly. Review: SELECT state, count(*) FROM pg_stat_activity GROUP BY state; to find idle connections", "percentage": 87, "note": "Architecture solution"}]$$::jsonb,
    'PostgreSQL superuser access. Connection pooler available (optional). Access to pg_stat_activity. Application configuration access.',
    'Connection accepted without too_many_connections error. Active connections below max_connections limit. Connection pool maintains steady state.',
    'Setting max_connections too high without server capacity. Not implementing connection pooling. Killing connections needed for application. Not investigating why connections spike.',
    0.91,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
),
(
    'PostgreSQL error: 08000 - connection_exception - General connection problems',
    'postgresql',
    'HIGH',
    $$[{"solution": "Test connectivity: psql -h host -U username -d database. Check connection string format: postgresql://user:password@localhost:5432/dbname. Verify credentials correct. Test with psql directly from shell. Enable verbose: psql -v ON_ERROR_STOP=on", "percentage": 92, "note": "Diagnostic approach"}, {"solution": "Check PostgreSQL logs: tail -f /var/log/postgresql/postgresql.log. Review pg_hba.conf for auth method: host all all 0.0.0.0/0 md5. Ensure listen_addresses correct: SHOW listen_addresses;", "percentage": 88, "note": "Configuration review"}]$$::jsonb,
    'PostgreSQL server running. Network connectivity available. Valid credentials. Access to postgresql.conf and pg_hba.conf.',
    'psql connects successfully. Connection string validated. Queries execute without connection_exception. Test scripts complete.',
    'Wrong port in connection string. Auth method mismatch in pg_hba.conf. Server not listening on correct address. Firewall blocking port. Wrong password/user.',
    0.92,
    'sonnet-4',
    NOW(),
    'https://www.postgresql.org/docs/current/errcodes-appendix.html'
);
